{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Kinetics Toolkit (ktk) Kinetics Toolkit (ktk) is an open-source, pure-python biomechanical library developed by Professor F\u00e9lix Ch\u00e9nier at Universit\u00e9 du Qu\u00e9bec \u00e0 Montr\u00e9al, Canada. It is a package of integrated classes and functions that aims to facilitate research in biomechanics using python. It does not attempt to provide a complete workflow from raw files to final analysis (although it may in a far future), or a main graphical user interface, or magical blackboxes that process everything automatically. Kinetics Toolkit is mainly addressed to researchers and students in biomechanics with a little background in programming, who may or may not already have a working workflow and who want to understand and control their data. This is why special attention is made to API documentation and tutorials, and to ensure the interoperability of ktk with other environments (using pandas Dataframes as intermediate data containers). Example markers = ktk.kinematics.read_c3d_file('my_file.c3d') ktk.Player(markers) This library is a work in progress and is still very incomplete. The stable version API is however mostly settled and generally well tested using a comprehensive set of unit tests and doc tests, and currently includes: timeseries.TimeSeries : a generic class to represent time-varying n-dimensional data and events, with many methods to extract, merge and subset TimeSeries data. kinematics : a module that loads c3d and n3d files as TimeSeries of 3d marker positions. player.Player : a class that allows visualizing 3d markers using a simple graphical user interface. and some helper functions. Please be warned that this is still mostly experimental software. If you are using ktk or are planning to be, you are warmly invited to contact me, first to say Hello :-), and so that I can warn you before doing major, possibly breaking changes. Also remind that I develop ktk mainly for my lab and I have limited resources for troubleshooting. You can however ask your questions and if I can answer, I'll do. While the development version is also accessible freely, it is aimed for my laboratory and is developed in parallel with my research projects following the needs of the moment. This version is not tested as much as the stable version and the API and implementations may change at any time. Credits Some external code has been directly included into ktk's source code. Here are the credits for these nice people. Clay Flannigan : icp - Python implementation of m-dimensional Iterative Closest Point method I also want to credit the people involved in ktk's dependencies: Benjamin Michaud : ezc3d - Easy to use C3D reader/writer for C++, Python and Matlab The dedicated people behind major software and packages used by ktk such as python, numpy, matplotlib, pandas, jupyter, pytest, pdoc3, etc.","title":"Home"},{"location":"index.html#kinetics-toolkit-ktk","text":"Kinetics Toolkit (ktk) is an open-source, pure-python biomechanical library developed by Professor F\u00e9lix Ch\u00e9nier at Universit\u00e9 du Qu\u00e9bec \u00e0 Montr\u00e9al, Canada. It is a package of integrated classes and functions that aims to facilitate research in biomechanics using python. It does not attempt to provide a complete workflow from raw files to final analysis (although it may in a far future), or a main graphical user interface, or magical blackboxes that process everything automatically. Kinetics Toolkit is mainly addressed to researchers and students in biomechanics with a little background in programming, who may or may not already have a working workflow and who want to understand and control their data. This is why special attention is made to API documentation and tutorials, and to ensure the interoperability of ktk with other environments (using pandas Dataframes as intermediate data containers). Example markers = ktk.kinematics.read_c3d_file('my_file.c3d') ktk.Player(markers) This library is a work in progress and is still very incomplete. The stable version API is however mostly settled and generally well tested using a comprehensive set of unit tests and doc tests, and currently includes: timeseries.TimeSeries : a generic class to represent time-varying n-dimensional data and events, with many methods to extract, merge and subset TimeSeries data. kinematics : a module that loads c3d and n3d files as TimeSeries of 3d marker positions. player.Player : a class that allows visualizing 3d markers using a simple graphical user interface. and some helper functions. Please be warned that this is still mostly experimental software. If you are using ktk or are planning to be, you are warmly invited to contact me, first to say Hello :-), and so that I can warn you before doing major, possibly breaking changes. Also remind that I develop ktk mainly for my lab and I have limited resources for troubleshooting. You can however ask your questions and if I can answer, I'll do. While the development version is also accessible freely, it is aimed for my laboratory and is developed in parallel with my research projects following the needs of the moment. This version is not tested as much as the stable version and the API and implementations may change at any time.","title":"Kinetics Toolkit (ktk)"},{"location":"index.html#credits","text":"Some external code has been directly included into ktk's source code. Here are the credits for these nice people. Clay Flannigan : icp - Python implementation of m-dimensional Iterative Closest Point method I also want to credit the people involved in ktk's dependencies: Benjamin Michaud : ezc3d - Easy to use C3D reader/writer for C++, Python and Matlab The dedicated people behind major software and packages used by ktk such as python, numpy, matplotlib, pandas, jupyter, pytest, pdoc3, etc.","title":"Credits"},{"location":"customize.html","text":"Customizing By default, importing ktk changes some defaults in IPython and matplotlib to get a more 'research' and less 'programming' experience. Please note that this does not affect anything besides visual representations. This behaviour can be changed by modifying ktk's configuration (ktk/config.py). In Spyder/IPython: >>> import ktk.config >>> edit ktk . config Modification to repr of dictionaries In ktk, data are often stored as dictionaries, which can lead to very large printouts when we simply want to see the dictionary's contents. Importing ktk changes the repr of dictionaries in IPython so that a summary of the dict's content is shown, more like the representation of a Matlab struct. For example, let's create a dummy dictionary: >>> import numpy as np >>> data = dict () >>> data [ 'data1' ] = np . arange ( 30 ) >>> data [ 'data2' ] = np . arange ( 30 ) ** 2 >>> data [ 'data3' ] = np . arange ( 30 ) ** 3 Before importing ktk: >>> data {'data1': array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]), 'data2': array([ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841]), 'data3': array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000, 1331, 1728, 2197, 2744, 3375, 4096, 4913, 5832, 6859, 8000, 9261, 10648, 12167, 13824, 15625, 17576, 19683, 21952, 24389])} After importing ktk: >>> import ktk >>> data { 'data1' : < array of shape ( 30 ,) > , 'data2' : < array of shape ( 30 ,) > , 'data3' : < array of shape ( 30 ,) > } Modification to repr of numpy's floats Numpy is set to display floats with floating point precision. Alternative defaults for matplotlib We assume that most work with figure is interactive, on screen. In that view, the following modifications are made to default matplotlib figures: The standard dpi is changed to 75, which allows for more space to work by reducing the font size on screen. The standard figure size is changed to [10, 5], which is a little bigger than the default and is thus more practical for interactive navigation. The default color order is changed to (rgbcmyko) with o being orange. The first colors, red, green and blue, are consistent the colours assigned to x, y and z in most 3D visualization softwares, and the next colours are consistent with Matlab's legacy color order.","title":"Customizing"},{"location":"customize.html#customizing","text":"By default, importing ktk changes some defaults in IPython and matplotlib to get a more 'research' and less 'programming' experience. Please note that this does not affect anything besides visual representations. This behaviour can be changed by modifying ktk's configuration (ktk/config.py). In Spyder/IPython: >>> import ktk.config >>> edit ktk . config","title":"Customizing"},{"location":"customize.html#modification-to-repr-of-dictionaries","text":"In ktk, data are often stored as dictionaries, which can lead to very large printouts when we simply want to see the dictionary's contents. Importing ktk changes the repr of dictionaries in IPython so that a summary of the dict's content is shown, more like the representation of a Matlab struct. For example, let's create a dummy dictionary: >>> import numpy as np >>> data = dict () >>> data [ 'data1' ] = np . arange ( 30 ) >>> data [ 'data2' ] = np . arange ( 30 ) ** 2 >>> data [ 'data3' ] = np . arange ( 30 ) ** 3 Before importing ktk: >>> data {'data1': array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]), 'data2': array([ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841]), 'data3': array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000, 1331, 1728, 2197, 2744, 3375, 4096, 4913, 5832, 6859, 8000, 9261, 10648, 12167, 13824, 15625, 17576, 19683, 21952, 24389])} After importing ktk: >>> import ktk >>> data { 'data1' : < array of shape ( 30 ,) > , 'data2' : < array of shape ( 30 ,) > , 'data3' : < array of shape ( 30 ,) > }","title":"Modification to repr of dictionaries"},{"location":"customize.html#modification-to-repr-of-numpys-floats","text":"Numpy is set to display floats with floating point precision.","title":"Modification to repr of numpy's floats"},{"location":"customize.html#alternative-defaults-for-matplotlib","text":"We assume that most work with figure is interactive, on screen. In that view, the following modifications are made to default matplotlib figures: The standard dpi is changed to 75, which allows for more space to work by reducing the font size on screen. The standard figure size is changed to [10, 5], which is a little bigger than the default and is thus more practical for interactive navigation. The default color order is changed to (rgbcmyko) with o being orange. The first colors, red, green and blue, are consistent the colours assigned to x, y and z in most 3D visualization softwares, and the next colours are consistent with Matlab's legacy color order.","title":"Alternative defaults for matplotlib"},{"location":"cycles.html","text":"cycles The cycles module allows detecting cycles in TimeSeries, time-normalize these cycles and select the most repeatable ones. Warning This module is experimental. Function names, signatures and implementations may change anytime. In this tutorial, we will load kinetics data from wheelchair propulsion using a csv file, and then extract the cycles in these data. import ktk import pandas as pd import numpy as np # Load the csv file df = pd . read_csv ( 'data/timeseries/smartwheel.csv' , usecols = [ 18 , 19 , 20 , 21 , 22 , 23 ], names = [ 'Forces[0]' , 'Forces[1]' , 'Forces[2]' , 'Moments[0]' , 'Moments[1]' , 'Moments[2]' ], nrows = 5000 ) # Assign time to the DataFrame's index, where the sampling rate is 240 Hz. df . index = np . arange ( df . shape [ 0 ]) / 240 # Convert this DataFrame to a TimeSeries ts = ktk . TimeSeries . from_dataframe ( df ) At this point, we have a TimeSeries that contains forces and moments. ts . plot ( 'Forces' ) To automatically detect the cycles in these data, we will add a third data, the total force, and use thresholds on this new data. ts . data [ 'Ftot' ] = np . sqrt ( np . sum ( ts . data [ 'Forces' ] ** 2 , 1 )) ts . plot ([ 'Forces' , 'Ftot' ]) Now let see how detecting cycles works. We will define the threshold values visually based on the figure above. test = ktk . cycles . find_cycles ( ts , 'Ftot' , event_names = ( 'push' , 'recovery' ), thresholds = ( 10 , 5 )) test . plot ([ 'Forces' , 'Ftot' ]) We observe that several cycles were wrongly detected during the first spike (that is a synchronization spike and not a push). We can reject those cycles by specifying a minimal length for the push phase. test = ktk . cycles . find_cycles ( ts , 'Ftot' , event_names = ( 'push' , 'recovery' ), thresholds = ( 10 , 5 ), minimum_length = 0.1 ) test . plot ([ 'Forces' , 'Ftot' ]) We also see that the detected cycles at the end are erratic and include pushes that should be excluded. We can exclude these pushes by specifying a minimal value for the push phase. test = ktk . cycles . find_cycles ( ts , 'Ftot' , event_names = ( 'push' , 'recovery' ), thresholds = ( 10 , 5 ), minimum_length = 0.1 , minimum_height = 50 ) test . plot ([ 'Forces' , 'Ftot' ])","title":"Cycles"},{"location":"cycles.html#cycles","text":"The cycles module allows detecting cycles in TimeSeries, time-normalize these cycles and select the most repeatable ones. Warning This module is experimental. Function names, signatures and implementations may change anytime. In this tutorial, we will load kinetics data from wheelchair propulsion using a csv file, and then extract the cycles in these data. import ktk import pandas as pd import numpy as np # Load the csv file df = pd . read_csv ( 'data/timeseries/smartwheel.csv' , usecols = [ 18 , 19 , 20 , 21 , 22 , 23 ], names = [ 'Forces[0]' , 'Forces[1]' , 'Forces[2]' , 'Moments[0]' , 'Moments[1]' , 'Moments[2]' ], nrows = 5000 ) # Assign time to the DataFrame's index, where the sampling rate is 240 Hz. df . index = np . arange ( df . shape [ 0 ]) / 240 # Convert this DataFrame to a TimeSeries ts = ktk . TimeSeries . from_dataframe ( df ) At this point, we have a TimeSeries that contains forces and moments. ts . plot ( 'Forces' ) To automatically detect the cycles in these data, we will add a third data, the total force, and use thresholds on this new data. ts . data [ 'Ftot' ] = np . sqrt ( np . sum ( ts . data [ 'Forces' ] ** 2 , 1 )) ts . plot ([ 'Forces' , 'Ftot' ]) Now let see how detecting cycles works. We will define the threshold values visually based on the figure above. test = ktk . cycles . find_cycles ( ts , 'Ftot' , event_names = ( 'push' , 'recovery' ), thresholds = ( 10 , 5 )) test . plot ([ 'Forces' , 'Ftot' ]) We observe that several cycles were wrongly detected during the first spike (that is a synchronization spike and not a push). We can reject those cycles by specifying a minimal length for the push phase. test = ktk . cycles . find_cycles ( ts , 'Ftot' , event_names = ( 'push' , 'recovery' ), thresholds = ( 10 , 5 ), minimum_length = 0.1 ) test . plot ([ 'Forces' , 'Ftot' ]) We also see that the detected cycles at the end are erratic and include pushes that should be excluded. We can exclude these pushes by specifying a minimal value for the push phase. test = ktk . cycles . find_cycles ( ts , 'Ftot' , event_names = ( 'push' , 'recovery' ), thresholds = ( 10 , 5 ), minimum_length = 0.1 , minimum_height = 50 ) test . plot ([ 'Forces' , 'Ftot' ])","title":"cycles"},{"location":"dbinterface.html","text":"DBInterface The DBInterface class is to be used exclusively at F\u00e9lix Ch\u00e9nier's lab. Its aim is to interface with the BIOMEC database (https://felixchenier.uqam.ca/biomec) to fetch all non-personal information about a specified ongoing project. It is necessary to understand how data files are stored in BIOMEC before reading this tutorial. Please note that the user/password combination used in this tutorial is not valid, and that you should have propel access to BIOMEC to use ktk.dbinterface. import ktk import os import shutil Connecting to a BIOMEC project The class constructor connects to the project and asks the user's credentials and the folder where the data files are stored. project = ktk.DBInterface(project_label) For example: project = ktk.DBInterface('FC_XX18A') The constructor can also be run non-interactively: project_label = 'dummyProject' user = 'dummyUser' password = 'dummyPassword' root_folder = 'data/dbinterface/FC_XX18A' url = '' url = 'http://localhost/biomec' # This line is only for this tutorial, # please don't execute it. project = ktk . DBInterface ( project_label , user = user , password = password , root_folder = root_folder , url = url ) Navigating in the project Just typing project gives an overview of the project's content. project -------------------------------------------------- DBInterface -------------------------------------------------- url: http://localhost/biomec user: dummyUser project_label: dummyProject root_folder: data/dbinterface/FC_XX18A -------------------------------------------------- participants: ['P1'] -------------------------------------------------- sessions: ['GymnaseN1', 'ArenaCESR1'] -------------------------------------------------- trials: ['Run1', 'Run2', 'Walk1', 'Walk2'] -------------------------------------------------- files: ['Kinematics', 'Kinetics', 'SyncedKinematics'] -------------------------------------------------- The method get is used to extract the project's contents. It always returns a dict with the fields corresponding to the request. For example: project . get () { 'Participants': <list of 1 items>, 'ProjectEndDate': None, 'ProjectID': 11, 'ProjectLabel': 'dummyProject', 'ProjectStartDate': None, 'ProjectTitle': 'Dummy Project for the ktkDBInterface tutorial' } project . get ( 'P1' ) { 'AIS': None, 'DateOfBirth': None, 'DateOfInjury': None, 'DominantSide': None, 'ParticipantID': 127, 'ParticipantLabel': 'P1', 'Pathology': 'Pathologie inconnue', 'ProjectID': 11, 'ProjectLabel': 'dummyProject', 'Sessions': <list of 2 items>, 'Sex': None, 'Traumatic': None, 'UID': 1 } project . get ( 'P1' )[ 'Sessions' ] ['GymnaseN1', 'ArenaCESR1'] project . get ( 'P1' , 'GymnaseN1' ) { 'ParticipantID': 127, 'ParticipantLabel': 'P1', 'PlaceLabel': 'GymnaseN', 'SessionDate': '2018-10-17', 'SessionID': 127, 'SessionLabel': 'GymnaseN1', 'SessionNotes': None, 'SessionRepetition': 1, 'Trials': <list of 4 items> } project . get ( 'P1' , 'GymnaseN1' )[ 'Trials' ] ['Run1', 'Run2', 'Walk1', 'Walk2'] project . get ( 'P1' , 'GymnaseN1' , 'Run1' ) { 'Files': <list of 3 items>, 'ParticipantLabel': 'P1', 'SessionID': 127, 'SessionLabel': 'GymnaseN1', 'TrialID': 3150, 'TrialLabel': 'Run1', 'TrialNotes': None, 'TrialRepetition': 1, 'TrialTypeDescription': None, 'TrialTypeID': 204, 'TrialTypeLabel': 'Run' } project . get ( 'P1' , 'GymnaseN1' , 'Run1' )[ 'Files' ] ['Kinematics', 'Kinetics', 'SyncedKinematics'] project . get ( 'P1' , 'GymnaseN1' , 'Run1' , 'Kinematics' ) { 'FileFormatExtension': None, 'FileFormatLabel': 'C3D', 'FileID': 6681, 'FileLabel': 'Kinematics', 'FileName': 'data/dbinterface/FC_XX18A/kinematics1_dbfid6681n.c3d', 'FileTypeDescription': 'Kinematics recorded using a Vicon system', 'FileTypeID': 29, 'FileTypeLabel': 'Kinematics', 'ParticipantLabel': 'P1', 'SessionLabel': 'GymnaseN1', 'TrialID': 3150, 'TrialLabel': 'Run1', 'dbfid': 'dbfid6681n' } project . get ( 'P1' , 'GymnaseN1' , 'Run1' , 'Kinematics' )[ 'FileName' ] 'data/dbinterface/FC_XX18A/kinematics1_dbfid6681n.c3d' Saving data to a BIOMEC referenced file The ktk library provides the function ktk.save to save a variable to a .ktk.zip file. The ktk.save function is helpful to save temporary results. However, sometimes we need to save results to BIOMEC so that these results become new inputs for subsequent work. In these case, we use the ktk.DBInterface's save method. For example, let's say we just synchronized the kinematics for Run1 of participant 1: synced_kinematics = { 'dummy_data' : 'Normally we would save something more useful' } We can save these kinematics as a file that is referenced in BIOMEC, using: project . save ( 'P1' , 'GymnaseN1' , 'Run1' , 'SyncedKinematics' , synced_kinematics ) 'data/dbinterface/FC_XX18A/SyncedKinematics/P1/GymnaseN1/dbfid11524n_{Run1}.ktk.zip' This creates the file entry in BIOMEC if needed, then save the file with a relevant name into the project folder. We can now obtain the file name using the get method introduced precedently. project . get ( 'P1' , 'GymnaseN1' , 'Run1' , 'SyncedKinematics' )[ 'FileName' ] 'data/dbinterface/FC_XX18A/SyncedKinematics/P1/GymnaseN1/dbfid11524n_{Run1}.ktk.zip' Loading data from a BIOMEC referenced file To load back data saved to BIOMEC, we use the ktk.DBInterface's load method. test = project . load ( 'P1' , 'GymnaseN1' , 'Run1' , 'SyncedKinematics' ) test { 'dummy_data': 'Normally we would save something more useful' } Let's do a little clean up before going on. shutil . rmtree ( root_folder + '/SyncedKinematics' ) Dealing with external software The DBInterface's save and load methods work very well for data that were processed in Python using ktk. However, things may get complicated when using external software to process data. In this example, we will synchronize the kinematics using an external synchronizing tool, then enter the resulting files into BIOMEC. We will work with these files: file_list = [] for trial in [ 'Walk1' , 'Walk2' , 'Run1' , 'Run2' ]: file_list . append ( project . get ( 'P1' , 'GymnaseN1' , trial , 'Kinematics' )[ 'FileName' ]) file_list ['data/dbinterface/FC_XX18A/kinematics3_dbfid6685n.c3d', 'data/dbinterface/FC_XX18A/kinematics4_dbfid6687n.c3d', 'data/dbinterface/FC_XX18A/kinematics1_dbfid6681n.c3d', 'data/dbinterface/FC_XX18A/kinematics2_dbfid6683n.c3d'] Let say we synchronized these files using an external software, and then we exported the synchronized files into a separate folder. (Here we will simply copy those files into a separate folder). os . mkdir ( root_folder + '/synchronized_files' ) for file in file_list : dest_file = file . replace ( root_folder , root_folder + '/synchronized_files' ) shutil . copyfile ( file , dest_file ) os . listdir ( root_folder + '/synchronized_files' ) ['kinematics3_dbfid6685n.c3d', 'kinematics2_dbfid6683n.c3d', 'kinematics4_dbfid6687n.c3d', 'kinematics1_dbfid6681n.c3d'] All is good, but the dbfids in the new synchronized_files folder refer to the original Kinematics file type, not to the SyncedKinematics file type. Moreover, there are now duplicate dbfids in the project: project . refresh () /Users/felix/Documents/Recherche/kineticstoolkit/ktk/dbinterface.py:156: UserWarning: Duplicate file(s) found. See duplicates property. warnings.warn('Duplicate file(s) found. See duplicates property.') project . duplicates [('data/dbinterface/FC_XX18A/synchronized_files/kinematics3_dbfid6685n.c3d', 'data/dbinterface/FC_XX18A/kinematics3_dbfid6685n.c3d'), ('data/dbinterface/FC_XX18A/synchronized_files/kinematics2_dbfid6683n.c3d', 'data/dbinterface/FC_XX18A/kinematics2_dbfid6683n.c3d'), ('data/dbinterface/FC_XX18A/synchronized_files/kinematics4_dbfid6687n.c3d', 'data/dbinterface/FC_XX18A/kinematics4_dbfid6687n.c3d'), ('data/dbinterface/FC_XX18A/synchronized_files/kinematics1_dbfid6681n.c3d', 'data/dbinterface/FC_XX18A/kinematics1_dbfid6681n.c3d')] Therefore we need to assign new dbfids to the files we just synchronized, so that they refer to SyncedKinematics entries in BIOMEC. The method batch_fix_file_type will help. project . batch_fix_file_type ( root_folder + '/synchronized_files' , 'SyncedKinematics' , create_file_entries = True , dry_run = False ) { 'Ignore': <list of 0 items>, 'NoFileTypeLabel': <list of 0 items>, 'Rename': <list of 4 items> } Now let see what happened in the synchronized_files folder: os . listdir ( root_folder + '/synchronized_files' ) ['kinematics4_dbfid11526n.c3d', 'kinematics1_dbfid11524n.c3d', 'kinematics3_dbfid8491n.c3d', 'kinematics2_dbfid11525n.c3d'] The files' dbfid have been updated so they now refer to SyncedKinematics and not to Kinematics anymore. Moreover, the project does not have duplicate dbfids anymore: project . refresh () Let's do a little clean up before going on. shutil . rmtree ( root_folder + '/synchronized_files' ) project . refresh () Including information in file names It can be difficult to deal with a bunch of numbered files without knowing their signification without looking in BIOMEC. The tag_files method allows adding the trial name to the file names, so that their context is a bit clearer and less error-prone. os . listdir ( root_folder ) ['kinetics_dbfid6688n.csv', 'kinematics3_dbfid6685n.c3d', 'kinetics_dbfid6684n.csv', 'kinetics_dbfid6682n.csv', 'kinematics2_dbfid6683n.c3d', 'kinematics4_dbfid6687n.c3d', 'kinetics_dbfid6686n.csv', 'kinematics1_dbfid6681n.c3d'] Include the trial name in the file names: project . tag_files ( include_trial_name = True , dry_run = False ) os . listdir ( root_folder ) Checking that the project is clean , without duplicates ... Renaming the files ... Refreshing project ... [ 'kinematics1_dbfid6681n_{Run1}.c3d' , 'kinetics_dbfid6682n_{Run1}.csv' , 'kinematics4_dbfid6687n_{Walk2}.c3d' , 'kinematics3_dbfid6685n_{Walk1}.c3d' , 'kinematics2_dbfid6683n_{Run2}.c3d' , 'kinetics_dbfid6688n_{Walk2}.csv' , 'kinetics_dbfid6684n_{Run2}.csv' , 'kinetics_dbfid6686n_{Walk1}.csv' ] Remove the trial name from the file names: project . tag_files ( include_trial_name = False , dry_run = False ) os . listdir ( root_folder ) Checking that the project is clean , without duplicates ... Renaming the files ... Refreshing project ... [ 'kinetics_dbfid6688n.csv' , 'kinematics3_dbfid6685n.c3d' , 'kinetics_dbfid6684n.csv' , 'kinetics_dbfid6682n.csv' , 'kinematics2_dbfid6683n.c3d' , 'kinematics4_dbfid6687n.c3d' , 'kinetics_dbfid6686n.csv' , 'kinematics1_dbfid6681n.c3d' ] For more information on DBInterface, please check the API Reference .","title":"DBInterface"},{"location":"dbinterface.html#dbinterface","text":"The DBInterface class is to be used exclusively at F\u00e9lix Ch\u00e9nier's lab. Its aim is to interface with the BIOMEC database (https://felixchenier.uqam.ca/biomec) to fetch all non-personal information about a specified ongoing project. It is necessary to understand how data files are stored in BIOMEC before reading this tutorial. Please note that the user/password combination used in this tutorial is not valid, and that you should have propel access to BIOMEC to use ktk.dbinterface. import ktk import os import shutil","title":"DBInterface"},{"location":"dbinterface.html#connecting-to-a-biomec-project","text":"The class constructor connects to the project and asks the user's credentials and the folder where the data files are stored. project = ktk.DBInterface(project_label) For example: project = ktk.DBInterface('FC_XX18A') The constructor can also be run non-interactively: project_label = 'dummyProject' user = 'dummyUser' password = 'dummyPassword' root_folder = 'data/dbinterface/FC_XX18A' url = '' url = 'http://localhost/biomec' # This line is only for this tutorial, # please don't execute it. project = ktk . DBInterface ( project_label , user = user , password = password , root_folder = root_folder , url = url )","title":"Connecting to a BIOMEC project"},{"location":"dbinterface.html#navigating-in-the-project","text":"Just typing project gives an overview of the project's content. project -------------------------------------------------- DBInterface -------------------------------------------------- url: http://localhost/biomec user: dummyUser project_label: dummyProject root_folder: data/dbinterface/FC_XX18A -------------------------------------------------- participants: ['P1'] -------------------------------------------------- sessions: ['GymnaseN1', 'ArenaCESR1'] -------------------------------------------------- trials: ['Run1', 'Run2', 'Walk1', 'Walk2'] -------------------------------------------------- files: ['Kinematics', 'Kinetics', 'SyncedKinematics'] -------------------------------------------------- The method get is used to extract the project's contents. It always returns a dict with the fields corresponding to the request. For example: project . get () { 'Participants': <list of 1 items>, 'ProjectEndDate': None, 'ProjectID': 11, 'ProjectLabel': 'dummyProject', 'ProjectStartDate': None, 'ProjectTitle': 'Dummy Project for the ktkDBInterface tutorial' } project . get ( 'P1' ) { 'AIS': None, 'DateOfBirth': None, 'DateOfInjury': None, 'DominantSide': None, 'ParticipantID': 127, 'ParticipantLabel': 'P1', 'Pathology': 'Pathologie inconnue', 'ProjectID': 11, 'ProjectLabel': 'dummyProject', 'Sessions': <list of 2 items>, 'Sex': None, 'Traumatic': None, 'UID': 1 } project . get ( 'P1' )[ 'Sessions' ] ['GymnaseN1', 'ArenaCESR1'] project . get ( 'P1' , 'GymnaseN1' ) { 'ParticipantID': 127, 'ParticipantLabel': 'P1', 'PlaceLabel': 'GymnaseN', 'SessionDate': '2018-10-17', 'SessionID': 127, 'SessionLabel': 'GymnaseN1', 'SessionNotes': None, 'SessionRepetition': 1, 'Trials': <list of 4 items> } project . get ( 'P1' , 'GymnaseN1' )[ 'Trials' ] ['Run1', 'Run2', 'Walk1', 'Walk2'] project . get ( 'P1' , 'GymnaseN1' , 'Run1' ) { 'Files': <list of 3 items>, 'ParticipantLabel': 'P1', 'SessionID': 127, 'SessionLabel': 'GymnaseN1', 'TrialID': 3150, 'TrialLabel': 'Run1', 'TrialNotes': None, 'TrialRepetition': 1, 'TrialTypeDescription': None, 'TrialTypeID': 204, 'TrialTypeLabel': 'Run' } project . get ( 'P1' , 'GymnaseN1' , 'Run1' )[ 'Files' ] ['Kinematics', 'Kinetics', 'SyncedKinematics'] project . get ( 'P1' , 'GymnaseN1' , 'Run1' , 'Kinematics' ) { 'FileFormatExtension': None, 'FileFormatLabel': 'C3D', 'FileID': 6681, 'FileLabel': 'Kinematics', 'FileName': 'data/dbinterface/FC_XX18A/kinematics1_dbfid6681n.c3d', 'FileTypeDescription': 'Kinematics recorded using a Vicon system', 'FileTypeID': 29, 'FileTypeLabel': 'Kinematics', 'ParticipantLabel': 'P1', 'SessionLabel': 'GymnaseN1', 'TrialID': 3150, 'TrialLabel': 'Run1', 'dbfid': 'dbfid6681n' } project . get ( 'P1' , 'GymnaseN1' , 'Run1' , 'Kinematics' )[ 'FileName' ] 'data/dbinterface/FC_XX18A/kinematics1_dbfid6681n.c3d'","title":"Navigating in the project"},{"location":"dbinterface.html#saving-data-to-a-biomec-referenced-file","text":"The ktk library provides the function ktk.save to save a variable to a .ktk.zip file. The ktk.save function is helpful to save temporary results. However, sometimes we need to save results to BIOMEC so that these results become new inputs for subsequent work. In these case, we use the ktk.DBInterface's save method. For example, let's say we just synchronized the kinematics for Run1 of participant 1: synced_kinematics = { 'dummy_data' : 'Normally we would save something more useful' } We can save these kinematics as a file that is referenced in BIOMEC, using: project . save ( 'P1' , 'GymnaseN1' , 'Run1' , 'SyncedKinematics' , synced_kinematics ) 'data/dbinterface/FC_XX18A/SyncedKinematics/P1/GymnaseN1/dbfid11524n_{Run1}.ktk.zip' This creates the file entry in BIOMEC if needed, then save the file with a relevant name into the project folder. We can now obtain the file name using the get method introduced precedently. project . get ( 'P1' , 'GymnaseN1' , 'Run1' , 'SyncedKinematics' )[ 'FileName' ] 'data/dbinterface/FC_XX18A/SyncedKinematics/P1/GymnaseN1/dbfid11524n_{Run1}.ktk.zip'","title":"Saving data to a BIOMEC referenced file"},{"location":"dbinterface.html#loading-data-from-a-biomec-referenced-file","text":"To load back data saved to BIOMEC, we use the ktk.DBInterface's load method. test = project . load ( 'P1' , 'GymnaseN1' , 'Run1' , 'SyncedKinematics' ) test { 'dummy_data': 'Normally we would save something more useful' } Let's do a little clean up before going on. shutil . rmtree ( root_folder + '/SyncedKinematics' )","title":"Loading data from a BIOMEC referenced file"},{"location":"dbinterface.html#dealing-with-external-software","text":"The DBInterface's save and load methods work very well for data that were processed in Python using ktk. However, things may get complicated when using external software to process data. In this example, we will synchronize the kinematics using an external synchronizing tool, then enter the resulting files into BIOMEC. We will work with these files: file_list = [] for trial in [ 'Walk1' , 'Walk2' , 'Run1' , 'Run2' ]: file_list . append ( project . get ( 'P1' , 'GymnaseN1' , trial , 'Kinematics' )[ 'FileName' ]) file_list ['data/dbinterface/FC_XX18A/kinematics3_dbfid6685n.c3d', 'data/dbinterface/FC_XX18A/kinematics4_dbfid6687n.c3d', 'data/dbinterface/FC_XX18A/kinematics1_dbfid6681n.c3d', 'data/dbinterface/FC_XX18A/kinematics2_dbfid6683n.c3d'] Let say we synchronized these files using an external software, and then we exported the synchronized files into a separate folder. (Here we will simply copy those files into a separate folder). os . mkdir ( root_folder + '/synchronized_files' ) for file in file_list : dest_file = file . replace ( root_folder , root_folder + '/synchronized_files' ) shutil . copyfile ( file , dest_file ) os . listdir ( root_folder + '/synchronized_files' ) ['kinematics3_dbfid6685n.c3d', 'kinematics2_dbfid6683n.c3d', 'kinematics4_dbfid6687n.c3d', 'kinematics1_dbfid6681n.c3d'] All is good, but the dbfids in the new synchronized_files folder refer to the original Kinematics file type, not to the SyncedKinematics file type. Moreover, there are now duplicate dbfids in the project: project . refresh () /Users/felix/Documents/Recherche/kineticstoolkit/ktk/dbinterface.py:156: UserWarning: Duplicate file(s) found. See duplicates property. warnings.warn('Duplicate file(s) found. See duplicates property.') project . duplicates [('data/dbinterface/FC_XX18A/synchronized_files/kinematics3_dbfid6685n.c3d', 'data/dbinterface/FC_XX18A/kinematics3_dbfid6685n.c3d'), ('data/dbinterface/FC_XX18A/synchronized_files/kinematics2_dbfid6683n.c3d', 'data/dbinterface/FC_XX18A/kinematics2_dbfid6683n.c3d'), ('data/dbinterface/FC_XX18A/synchronized_files/kinematics4_dbfid6687n.c3d', 'data/dbinterface/FC_XX18A/kinematics4_dbfid6687n.c3d'), ('data/dbinterface/FC_XX18A/synchronized_files/kinematics1_dbfid6681n.c3d', 'data/dbinterface/FC_XX18A/kinematics1_dbfid6681n.c3d')] Therefore we need to assign new dbfids to the files we just synchronized, so that they refer to SyncedKinematics entries in BIOMEC. The method batch_fix_file_type will help. project . batch_fix_file_type ( root_folder + '/synchronized_files' , 'SyncedKinematics' , create_file_entries = True , dry_run = False ) { 'Ignore': <list of 0 items>, 'NoFileTypeLabel': <list of 0 items>, 'Rename': <list of 4 items> } Now let see what happened in the synchronized_files folder: os . listdir ( root_folder + '/synchronized_files' ) ['kinematics4_dbfid11526n.c3d', 'kinematics1_dbfid11524n.c3d', 'kinematics3_dbfid8491n.c3d', 'kinematics2_dbfid11525n.c3d'] The files' dbfid have been updated so they now refer to SyncedKinematics and not to Kinematics anymore. Moreover, the project does not have duplicate dbfids anymore: project . refresh () Let's do a little clean up before going on. shutil . rmtree ( root_folder + '/synchronized_files' ) project . refresh ()","title":"Dealing with external software"},{"location":"dbinterface.html#including-information-in-file-names","text":"It can be difficult to deal with a bunch of numbered files without knowing their signification without looking in BIOMEC. The tag_files method allows adding the trial name to the file names, so that their context is a bit clearer and less error-prone. os . listdir ( root_folder ) ['kinetics_dbfid6688n.csv', 'kinematics3_dbfid6685n.c3d', 'kinetics_dbfid6684n.csv', 'kinetics_dbfid6682n.csv', 'kinematics2_dbfid6683n.c3d', 'kinematics4_dbfid6687n.c3d', 'kinetics_dbfid6686n.csv', 'kinematics1_dbfid6681n.c3d'] Include the trial name in the file names: project . tag_files ( include_trial_name = True , dry_run = False ) os . listdir ( root_folder ) Checking that the project is clean , without duplicates ... Renaming the files ... Refreshing project ... [ 'kinematics1_dbfid6681n_{Run1}.c3d' , 'kinetics_dbfid6682n_{Run1}.csv' , 'kinematics4_dbfid6687n_{Walk2}.c3d' , 'kinematics3_dbfid6685n_{Walk1}.c3d' , 'kinematics2_dbfid6683n_{Run2}.c3d' , 'kinetics_dbfid6688n_{Walk2}.csv' , 'kinetics_dbfid6684n_{Run2}.csv' , 'kinetics_dbfid6686n_{Walk1}.csv' ] Remove the trial name from the file names: project . tag_files ( include_trial_name = False , dry_run = False ) os . listdir ( root_folder ) Checking that the project is clean , without duplicates ... Renaming the files ... Refreshing project ... [ 'kinetics_dbfid6688n.csv' , 'kinematics3_dbfid6685n.c3d' , 'kinetics_dbfid6684n.csv' , 'kinetics_dbfid6682n.csv' , 'kinematics2_dbfid6683n.c3d' , 'kinematics4_dbfid6687n.c3d' , 'kinetics_dbfid6686n.csv' , 'kinematics1_dbfid6681n.c3d' ] For more information on DBInterface, please check the API Reference .","title":"Including information in file names"},{"location":"filters.html","text":"Filters The filters module wraps some filters to use directly with ktk's TimeSeries objects. These filters are convenience wrappers for scipy's filters. import ktk import numpy as np import matplotlib.pyplot as plt Smoothing and derivating a TimeSeries with a Savitzky-Golay Filter This filter applies the scipy.signal.savgol_filter filter to a TimeSeries. To see it in effect, let's define a TimeSeries with some dummy data. time = np . linspace ( 0 , 1 , 100 ) tsin = ktk . TimeSeries ( time = time ) tsin . data [ 'data1' ] = np . sin ( time * 2 * np . pi ) tsin . data [ 'data2' ] = time ** 2 To smooth the TimeSeries' data: y = ktk . filters . savgol ( tsin , window_length = 3 , poly_order = 2 , deriv = 0 ) y . plot () To calculate the first derivative of the TimeSeries' data: doty = ktk . filters . savgol ( tsin , window_length = 3 , poly_order = 2 , deriv = 1 ) doty . plot () To calculate the second derivative of the TimeSeries' data: ddoty = ktk . filters . savgol ( tsin , window_length = 3 , poly_order = 2 , deriv = 2 ) ddoty . plot () And so on. We can also smooth a signal with the smoothing filter smooth , which is a convenience function that smooths a TimeSeries using a moving average of N samples. It calls the Savitzky-Golay filter with a polynom order of 0. For example, let's define a TimeSeries with some random data inside: data = np . array ( [ 0.7060 , 0.0318 , 0.2769 , 0.0462 , 0.0971 , 0.8235 , 0.6948 , 0.3171 , 0.9502 , 0.0344 , 0.4387 , 0.3816 , 0.7655 , 0.7952 , 0.1869 , 0.4898 , 0.4456 , 0.6463 , 0.7094 , 0.7547 , 0.2760 , 0.6797 , 0.6551 , 0.1626 , 0.1190 , 0.4984 , 0.9597 , 0.3404 , 0.5853 , 0.2238 ]) ts = ktk . TimeSeries () ts . data [ 'data' ] = data ts . time = np . linspace ( 0 , 1 , data . shape [ 0 ]) ts . plot () To smooth this function using a moving average on 5 samples: y = ktk . filters . smooth ( ts , 5 ) y . plot () Butterworth filter The butter method applies a butterworth filter on a TimeSeries, using scipy.signal 's functions. Let's define a TimeSeries with a sinusoidal signal at 1 Hz, with an amplitude of 1: ts = ktk . TimeSeries ( time = np . linspace ( 0 , 30 , 1000 )) ts . data [ 'data' ] = np . sin ( 2 * np . pi * ts . time ) ts . plot () To filter at 1 Hz, with an order 1: new_ts = ktk . filters . butter ( ts , 1 , order = 1 , btype = 'low' ) new_ts . plot () For more information on filters, please check the API Reference .","title":"Filters"},{"location":"filters.html#filters","text":"The filters module wraps some filters to use directly with ktk's TimeSeries objects. These filters are convenience wrappers for scipy's filters. import ktk import numpy as np import matplotlib.pyplot as plt","title":"Filters"},{"location":"filters.html#smoothing-and-derivating-a-timeseries-with-a-savitzky-golay-filter","text":"This filter applies the scipy.signal.savgol_filter filter to a TimeSeries. To see it in effect, let's define a TimeSeries with some dummy data. time = np . linspace ( 0 , 1 , 100 ) tsin = ktk . TimeSeries ( time = time ) tsin . data [ 'data1' ] = np . sin ( time * 2 * np . pi ) tsin . data [ 'data2' ] = time ** 2 To smooth the TimeSeries' data: y = ktk . filters . savgol ( tsin , window_length = 3 , poly_order = 2 , deriv = 0 ) y . plot () To calculate the first derivative of the TimeSeries' data: doty = ktk . filters . savgol ( tsin , window_length = 3 , poly_order = 2 , deriv = 1 ) doty . plot () To calculate the second derivative of the TimeSeries' data: ddoty = ktk . filters . savgol ( tsin , window_length = 3 , poly_order = 2 , deriv = 2 ) ddoty . plot () And so on. We can also smooth a signal with the smoothing filter smooth , which is a convenience function that smooths a TimeSeries using a moving average of N samples. It calls the Savitzky-Golay filter with a polynom order of 0. For example, let's define a TimeSeries with some random data inside: data = np . array ( [ 0.7060 , 0.0318 , 0.2769 , 0.0462 , 0.0971 , 0.8235 , 0.6948 , 0.3171 , 0.9502 , 0.0344 , 0.4387 , 0.3816 , 0.7655 , 0.7952 , 0.1869 , 0.4898 , 0.4456 , 0.6463 , 0.7094 , 0.7547 , 0.2760 , 0.6797 , 0.6551 , 0.1626 , 0.1190 , 0.4984 , 0.9597 , 0.3404 , 0.5853 , 0.2238 ]) ts = ktk . TimeSeries () ts . data [ 'data' ] = data ts . time = np . linspace ( 0 , 1 , data . shape [ 0 ]) ts . plot () To smooth this function using a moving average on 5 samples: y = ktk . filters . smooth ( ts , 5 ) y . plot ()","title":"Smoothing and derivating a TimeSeries with a Savitzky-Golay Filter"},{"location":"filters.html#butterworth-filter","text":"The butter method applies a butterworth filter on a TimeSeries, using scipy.signal 's functions. Let's define a TimeSeries with a sinusoidal signal at 1 Hz, with an amplitude of 1: ts = ktk . TimeSeries ( time = np . linspace ( 0 , 30 , 1000 )) ts . data [ 'data' ] = np . sin ( 2 * np . pi * ts . time ) ts . plot () To filter at 1 Hz, with an order 1: new_ts = ktk . filters . butter ( ts , 1 , order = 1 , btype = 'low' ) new_ts . plot () For more information on filters, please check the API Reference .","title":"Butterworth filter"},{"location":"geometry.html","text":"Geometry The ktk.geometry module simplifies the calculation of linear algebric operations on series of points, vectors and transformation matrices. Array convention Every point, vector or matrix is considered as a series, where the dimensions of the array are: First dimension (N) : time. Constants are also reprented as series: they have only one data on the first dimension. Second dimension (4) : point/vector coordinates, or matrix line. Third dimension (M, optional) : point index (for sets of point), or matrix column. For example, floats, points, vectors, sets and matrices are expressed as following: Single float [a] value = array[0] Series of floats [a(t0), a(t1), a(t2), ...] value = array[i_time] Series of points [[ x ( t0 ), y ( t0 ), z ( t0 ), 1 .], [ y ( t1 ), y ( t1 ), z ( t1 ), 1 .], [ y ( t2 ), y ( t2 ), z ( t2 ), 1 .], [ ... , ... , ... , ...]] value = array [ i_time , i_coordinate ] Series of vectors [[ x ( t0 ), y ( t0 ), z ( t0 ), 0 .], [ y ( t1 ), y ( t1 ), z ( t1 ), 0 .], [ y ( t2 ), y ( t2 ), z ( t2 ), 0 .], [ ... , ... , ... , ...]] value = array [ i_time , i_coordinate ] Series of sets of point [[[ x1 ( t1 ), x2 ( t1 ), x3 ( t1 ), x4 ( t1 )], [ y1 ( t1 ), y2 ( t1 ), y3 ( t1 ), y4 ( t1 )], [ z1 ( t1 ), z2 ( t1 ), z3 ( t1 ), z4 ( t1 )], [ 1 ., 1 ., 1 ., 1 . ]], [[ x1 ( t2 ), x2 ( t2 ), x3 ( t2 ), x4 ( t2 )], [ y1 ( t2 ), y2 ( t2 ), y3 ( t2 ), y4 ( t2 )], [ z1 ( t2 ), z2 ( t2 ), z3 ( t2 ), z4 ( t2 )], [ 1 ., 1 ., 1 ., 1 . ]], ... ] value = array [ i_time , i_coordinate , i_point ] Series of matrices [[[ R11 ( t1 ), R12 ( t1 ), R13 ( t1 ), Tx ( t1 )], [ R21 ( t1 ), R22 ( t1 ), R23 ( t1 ), Ty ( t1 )], [ R31 ( t1 ), R32 ( t1 ), R33 ( t1 ), Tz ( t1 )], [ 0 ., 0 ., 0 ., 1 . ]], [[ R11 ( t2 ), R12 ( t2 ), R13 ( t2 ), Tx ( t2 )], [ R21 ( t2 ), R22 ( t2 ), R23 ( t2 ), Ty ( t2 )], [ R31 ( t2 ), R32 ( t2 ), R33 ( t2 ), Tz ( t2 )], [ 0 ., 0 ., 0 ., 1 . ]], ... ] value = array [ i_time , i_row , i_column ] import ktk import numpy as np Matrix multiplication To facilitate the multiplication of series, ktk.geometry provides a matmul function that matches both matrices' time dimensions before applying the numpy's @ or * operator accordingly on each time iteration. Therefore, when dealing with series of floats, vectors, points or matrices, it is advisable to use ktk.geometry's matmul instead of the @ operator, which will garranty to follow ktk's array convention. For example: Matrix multiplication between a matrix and a series of points # Single rigid transformation matrix T = np . array ([[[ 1 , 0 , 0 , 0 ], [ 0 , 1 , 0 , 0 ], [ 0 , 0 , 1 , 0 ], [ 0 , 0 , 0 , 1 ]]]) # Series of 3 points points = np . array ([[ 0 , 1 , 0 , 1 ], [ 1 , 1 , 0 , 1 ], [ 2 , 1 , 0 , 1 ]]) ktk . geometry . matmul ( T , points ) array([[0., 1., 0., 1.], [1., 1., 0., 1.], [2., 1., 0., 1.]]) Multiplication between a series of floats and a series of vectors # Series of 3 floats floats = np . array ([ 0. , 0.5 , 1. , 1.5 ]) # Series of 3 vectors vectors = np . array ([[ 1 , 1 , 0 , 0 ], [ 2 , 1 , 0 , 0 ], [ 3 , 1 , 0 , 0 ], [ 4 , 1 , 0 , 0 ]]) ktk . geometry . matmul ( floats , vectors ) array([[0. , 0. , 0. , 0. ], [1. , 0.5, 0. , 0. ], [3. , 1. , 0. , 0. ], [6. , 1.5, 0. , 0. ]]) Dot product between a series of points and a single point # Series of 3 points points = np . array ([[ 0 , 1 , 0 , 1 ], [ 1 , 1 , 0 , 1 ], [ 2 , 1 , 0 , 1 ]]) # Single point point = np . array ([[ 2 , 3 , 4 , 1 ]]) ktk . geometry . matmul ( points , point ) array([4., 6., 8.]) Creating series of rotation matrices The function ktk.geometry.create_rotation_matrices allows creating series of Nx4x4 matrices around a given axis. For example, this command creates a rotation matrix of 90 degrees around the x axis. Note that the angle argument is a list or an array, to comply with the ktk.geometry 's convention above. ktk . geometry . create_rotation_matrices ( 'x' , [ np . pi / 2 ]) array([[[ 1., 0., 0., 0.], [ 0., 0., -1., 0.], [ 0., 1., 0., 0.], [ 0., 0., 0., 1.]]]) As another example, this will create a series of 100 rotation matrices around the z axis, from 0 to 360 degrees: ktk . geometry . create_rotation_matrices ( 'z' , np . linspace ( 0 , 2 * np . pi , 100 )) array ([[[ 1 . , - 0 . , 0 . , 0 . ], [ 0 . , 1 . , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], [[ 0 . 99798668 , - 0 . 06342392 , 0 . , 0 . ], [ 0 . 06342392 , 0 . 99798668 , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], [[ 0 . 99195481 , - 0 . 12659245 , 0 . , 0 . ], [ 0 . 12659245 , 0 . 99195481 , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], ..., [[ 0 . 99195481 , 0 . 12659245 , 0 . , 0 . ], [ - 0 . 12659245 , 0 . 99195481 , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], [[ 0 . 99798668 , 0 . 06342392 , 0 . , 0 . ], [ - 0 . 06342392 , 0 . 99798668 , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], [[ 1 . , 0 . , 0 . , 0 . ], [ - 0 . , 1 . , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]]]) Creating series of reference frames Let's say we have the position of three markers, and we want to create a reference frame based on these markers. This is the aim of the create_reference_frames function. If the markers are at these positions (0, 0, 0), (1, 0, 0) and (0, 1, 0): global_markers = np . array ( [[[ 0. , 1. , 0. ], [ 0. , 0. , 1. ], [ 0. , 0. , 0. ], [ 1. , 1. , 1. ]]]) Now we can create a reference frame based on these three markers. Please consult the API reference for the different marker configurations available for the creation of reference frames. T = ktk . geometry . create_reference_frames ( global_markers ) T array([[[-0.70710678, 0.70710678, 0. , 0.33333333], [-0.70710678, -0.70710678, 0. , 0.33333333], [ 0. , 0. , 1. , 0. ], [ 0. , 0. , 0. , 1. ]]]) Calculating local coordinates We now have a reference frame defined from three markers. If we are interested to know the local position of these markers in the new-created frame, we can use the function get_local_coordinates . local_markers = ktk . geometry . get_local_coordinates ( global_markers , T ) local_markers array([[[ 0.47140452, -0.23570226, -0.23570226], [ 0. , 0.70710678, -0.70710678], [ 0. , 0. , 0. ], [ 1. , 1. , 1. ]]]) Calculating global coordinates In the case we have the markers' local coordinates and we would like to express these markers in the global reference frame, we would use the mirror function get_global_coordinates . ktk . geometry . get_global_coordinates ( local_markers , T ) array([[[0., 1., 0.], [0., 0., 1.], [0., 0., 0.], [1., 1., 1.]]]) in which case the results is effectively the global points as we defined them at the beginning.","title":"Geometry"},{"location":"geometry.html#geometry","text":"The ktk.geometry module simplifies the calculation of linear algebric operations on series of points, vectors and transformation matrices.","title":"Geometry"},{"location":"geometry.html#array-convention","text":"Every point, vector or matrix is considered as a series, where the dimensions of the array are: First dimension (N) : time. Constants are also reprented as series: they have only one data on the first dimension. Second dimension (4) : point/vector coordinates, or matrix line. Third dimension (M, optional) : point index (for sets of point), or matrix column. For example, floats, points, vectors, sets and matrices are expressed as following: Single float [a] value = array[0] Series of floats [a(t0), a(t1), a(t2), ...] value = array[i_time] Series of points [[ x ( t0 ), y ( t0 ), z ( t0 ), 1 .], [ y ( t1 ), y ( t1 ), z ( t1 ), 1 .], [ y ( t2 ), y ( t2 ), z ( t2 ), 1 .], [ ... , ... , ... , ...]] value = array [ i_time , i_coordinate ] Series of vectors [[ x ( t0 ), y ( t0 ), z ( t0 ), 0 .], [ y ( t1 ), y ( t1 ), z ( t1 ), 0 .], [ y ( t2 ), y ( t2 ), z ( t2 ), 0 .], [ ... , ... , ... , ...]] value = array [ i_time , i_coordinate ] Series of sets of point [[[ x1 ( t1 ), x2 ( t1 ), x3 ( t1 ), x4 ( t1 )], [ y1 ( t1 ), y2 ( t1 ), y3 ( t1 ), y4 ( t1 )], [ z1 ( t1 ), z2 ( t1 ), z3 ( t1 ), z4 ( t1 )], [ 1 ., 1 ., 1 ., 1 . ]], [[ x1 ( t2 ), x2 ( t2 ), x3 ( t2 ), x4 ( t2 )], [ y1 ( t2 ), y2 ( t2 ), y3 ( t2 ), y4 ( t2 )], [ z1 ( t2 ), z2 ( t2 ), z3 ( t2 ), z4 ( t2 )], [ 1 ., 1 ., 1 ., 1 . ]], ... ] value = array [ i_time , i_coordinate , i_point ] Series of matrices [[[ R11 ( t1 ), R12 ( t1 ), R13 ( t1 ), Tx ( t1 )], [ R21 ( t1 ), R22 ( t1 ), R23 ( t1 ), Ty ( t1 )], [ R31 ( t1 ), R32 ( t1 ), R33 ( t1 ), Tz ( t1 )], [ 0 ., 0 ., 0 ., 1 . ]], [[ R11 ( t2 ), R12 ( t2 ), R13 ( t2 ), Tx ( t2 )], [ R21 ( t2 ), R22 ( t2 ), R23 ( t2 ), Ty ( t2 )], [ R31 ( t2 ), R32 ( t2 ), R33 ( t2 ), Tz ( t2 )], [ 0 ., 0 ., 0 ., 1 . ]], ... ] value = array [ i_time , i_row , i_column ] import ktk import numpy as np","title":"Array convention"},{"location":"geometry.html#matrix-multiplication","text":"To facilitate the multiplication of series, ktk.geometry provides a matmul function that matches both matrices' time dimensions before applying the numpy's @ or * operator accordingly on each time iteration. Therefore, when dealing with series of floats, vectors, points or matrices, it is advisable to use ktk.geometry's matmul instead of the @ operator, which will garranty to follow ktk's array convention. For example: Matrix multiplication between a matrix and a series of points # Single rigid transformation matrix T = np . array ([[[ 1 , 0 , 0 , 0 ], [ 0 , 1 , 0 , 0 ], [ 0 , 0 , 1 , 0 ], [ 0 , 0 , 0 , 1 ]]]) # Series of 3 points points = np . array ([[ 0 , 1 , 0 , 1 ], [ 1 , 1 , 0 , 1 ], [ 2 , 1 , 0 , 1 ]]) ktk . geometry . matmul ( T , points ) array([[0., 1., 0., 1.], [1., 1., 0., 1.], [2., 1., 0., 1.]]) Multiplication between a series of floats and a series of vectors # Series of 3 floats floats = np . array ([ 0. , 0.5 , 1. , 1.5 ]) # Series of 3 vectors vectors = np . array ([[ 1 , 1 , 0 , 0 ], [ 2 , 1 , 0 , 0 ], [ 3 , 1 , 0 , 0 ], [ 4 , 1 , 0 , 0 ]]) ktk . geometry . matmul ( floats , vectors ) array([[0. , 0. , 0. , 0. ], [1. , 0.5, 0. , 0. ], [3. , 1. , 0. , 0. ], [6. , 1.5, 0. , 0. ]]) Dot product between a series of points and a single point # Series of 3 points points = np . array ([[ 0 , 1 , 0 , 1 ], [ 1 , 1 , 0 , 1 ], [ 2 , 1 , 0 , 1 ]]) # Single point point = np . array ([[ 2 , 3 , 4 , 1 ]]) ktk . geometry . matmul ( points , point ) array([4., 6., 8.])","title":"Matrix multiplication"},{"location":"geometry.html#creating-series-of-rotation-matrices","text":"The function ktk.geometry.create_rotation_matrices allows creating series of Nx4x4 matrices around a given axis. For example, this command creates a rotation matrix of 90 degrees around the x axis. Note that the angle argument is a list or an array, to comply with the ktk.geometry 's convention above. ktk . geometry . create_rotation_matrices ( 'x' , [ np . pi / 2 ]) array([[[ 1., 0., 0., 0.], [ 0., 0., -1., 0.], [ 0., 1., 0., 0.], [ 0., 0., 0., 1.]]]) As another example, this will create a series of 100 rotation matrices around the z axis, from 0 to 360 degrees: ktk . geometry . create_rotation_matrices ( 'z' , np . linspace ( 0 , 2 * np . pi , 100 )) array ([[[ 1 . , - 0 . , 0 . , 0 . ], [ 0 . , 1 . , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], [[ 0 . 99798668 , - 0 . 06342392 , 0 . , 0 . ], [ 0 . 06342392 , 0 . 99798668 , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], [[ 0 . 99195481 , - 0 . 12659245 , 0 . , 0 . ], [ 0 . 12659245 , 0 . 99195481 , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], ..., [[ 0 . 99195481 , 0 . 12659245 , 0 . , 0 . ], [ - 0 . 12659245 , 0 . 99195481 , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], [[ 0 . 99798668 , 0 . 06342392 , 0 . , 0 . ], [ - 0 . 06342392 , 0 . 99798668 , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]], [[ 1 . , 0 . , 0 . , 0 . ], [ - 0 . , 1 . , 0 . , 0 . ], [ 0 . , 0 . , 1 . , 0 . ], [ 0 . , 0 . , 0 . , 1 . ]]])","title":"Creating series of rotation matrices"},{"location":"geometry.html#creating-series-of-reference-frames","text":"Let's say we have the position of three markers, and we want to create a reference frame based on these markers. This is the aim of the create_reference_frames function. If the markers are at these positions (0, 0, 0), (1, 0, 0) and (0, 1, 0): global_markers = np . array ( [[[ 0. , 1. , 0. ], [ 0. , 0. , 1. ], [ 0. , 0. , 0. ], [ 1. , 1. , 1. ]]]) Now we can create a reference frame based on these three markers. Please consult the API reference for the different marker configurations available for the creation of reference frames. T = ktk . geometry . create_reference_frames ( global_markers ) T array([[[-0.70710678, 0.70710678, 0. , 0.33333333], [-0.70710678, -0.70710678, 0. , 0.33333333], [ 0. , 0. , 1. , 0. ], [ 0. , 0. , 0. , 1. ]]])","title":"Creating series of reference frames"},{"location":"geometry.html#calculating-local-coordinates","text":"We now have a reference frame defined from three markers. If we are interested to know the local position of these markers in the new-created frame, we can use the function get_local_coordinates . local_markers = ktk . geometry . get_local_coordinates ( global_markers , T ) local_markers array([[[ 0.47140452, -0.23570226, -0.23570226], [ 0. , 0.70710678, -0.70710678], [ 0. , 0. , 0. ], [ 1. , 1. , 1. ]]])","title":"Calculating local coordinates"},{"location":"geometry.html#calculating-global-coordinates","text":"In the case we have the markers' local coordinates and we would like to express these markers in the global reference frame, we would use the mirror function get_global_coordinates . ktk . geometry . get_global_coordinates ( local_markers , T ) array([[[0., 1., 0.], [0., 0., 1.], [0., 0., 0.], [1., 1., 1.]]]) in which case the results is effectively the global points as we defined them at the beginning.","title":"Calculating global coordinates"},{"location":"install.html","text":"Installing Requirements Although ktk is distributed via pip , I strongly recommend using a conda environment, if only to install ezc3d which is required for opening c3d files and which is distributed via conda-forge . Download and install Anaconda or Miniconda I suggest Miniconda as it is way smaller than the whole Anaconda suite. Miniconda website - Select the Python 3.7 version that corresponds to your system. Create a virtual environment and install the external dependencies Open an Anaconda Prompt (on Windows) or a terminal (on macOS and Linux) and type these commands one by one to create a ktk virtual environment and install the dependencies in this environment. conda create - n ktk conda activate ktk conda install - c conda - forge python = 3 . 7 matplotlib scipy pandas scikit - learn ezc3d Additional dependencies for the private development version: conda install -c conda-forge git pytest jupyter spyder pdoc3 mkdocs mkdocs-material mkdocs-material-extensions Installing ktk Stable version The public, open-source version of ktk is distributed va pip . Open an Anaconda Prompt (on Windows) or a terminal (on macOS and Linux), and type: pip install ktk Development version Clone ktk from bitbucket: On Windows, open Git Bash (ktk) from the Anaconda3 menu. On macOS or Linux, open a terminal. In that terminal, run this command. This will create a folder named 'kineticstoolkit' in the current folder. You may wish to facultatively change the current folder before running theses commands. git clone https://bitbucket.org/felixchenier/kineticstoolkit.git') Configuring Spyder On Windows, open Spyder by selecting 'Spyder (ktk)' from the Anaconda3 menu. On macOS and Linux, open a terminal and write: conda activate ktk spyder Qt5 backend KTK uses Matplotlib for user interaction. To set it permanently in Spyder, go to the Spyder's preferences, to the IPython console item, then to the Graphics pane. In the Graphics backend box, select Qt5 . Python path (development version only) In Spyder, look for the PYTHONPATH manager . Open this manager and add the kineticstoolkit folder that you just cloned to the python path. Restart Spyder. Writing import ktk should now find and import ktk without error. Keeping ktk up to date For the stable version, open an Anaconda Prompt (on Windows) or a terminal (on macOS and Linux), and type: pip upgrade ktk For the development version, in an IPython console, type: import ktk ktk . update ()","title":"Installing"},{"location":"install.html#installing","text":"","title":"Installing"},{"location":"install.html#requirements","text":"Although ktk is distributed via pip , I strongly recommend using a conda environment, if only to install ezc3d which is required for opening c3d files and which is distributed via conda-forge .","title":"Requirements"},{"location":"install.html#download-and-install-anaconda-or-miniconda","text":"I suggest Miniconda as it is way smaller than the whole Anaconda suite. Miniconda website - Select the Python 3.7 version that corresponds to your system.","title":"Download and install Anaconda or Miniconda"},{"location":"install.html#create-a-virtual-environment-and-install-the-external-dependencies","text":"Open an Anaconda Prompt (on Windows) or a terminal (on macOS and Linux) and type these commands one by one to create a ktk virtual environment and install the dependencies in this environment. conda create - n ktk conda activate ktk conda install - c conda - forge python = 3 . 7 matplotlib scipy pandas scikit - learn ezc3d Additional dependencies for the private development version: conda install -c conda-forge git pytest jupyter spyder pdoc3 mkdocs mkdocs-material mkdocs-material-extensions","title":"Create a virtual environment and install the external dependencies"},{"location":"install.html#installing-ktk","text":"","title":"Installing ktk"},{"location":"install.html#stable-version","text":"The public, open-source version of ktk is distributed va pip . Open an Anaconda Prompt (on Windows) or a terminal (on macOS and Linux), and type: pip install ktk","title":"Stable version"},{"location":"install.html#development-version","text":"Clone ktk from bitbucket: On Windows, open Git Bash (ktk) from the Anaconda3 menu. On macOS or Linux, open a terminal. In that terminal, run this command. This will create a folder named 'kineticstoolkit' in the current folder. You may wish to facultatively change the current folder before running theses commands. git clone https://bitbucket.org/felixchenier/kineticstoolkit.git')","title":"Development version"},{"location":"install.html#configuring-spyder","text":"On Windows, open Spyder by selecting 'Spyder (ktk)' from the Anaconda3 menu. On macOS and Linux, open a terminal and write: conda activate ktk spyder","title":"Configuring Spyder"},{"location":"install.html#qt5-backend","text":"KTK uses Matplotlib for user interaction. To set it permanently in Spyder, go to the Spyder's preferences, to the IPython console item, then to the Graphics pane. In the Graphics backend box, select Qt5 .","title":"Qt5 backend"},{"location":"install.html#python-path-development-version-only","text":"In Spyder, look for the PYTHONPATH manager . Open this manager and add the kineticstoolkit folder that you just cloned to the python path. Restart Spyder. Writing import ktk should now find and import ktk without error.","title":"Python path (development version only)"},{"location":"install.html#keeping-ktk-up-to-date","text":"For the stable version, open an Anaconda Prompt (on Windows) or a terminal (on macOS and Linux), and type: pip upgrade ktk For the development version, in an IPython console, type: import ktk ktk . update ()","title":"Keeping ktk up to date"},{"location":"inversedynamics.html","text":"Inverse Dynamics The inversedynamics calculates the proximal forces and moments based on the segment's kinematics and distal forces and moments, based on the general method published in: Cite R. Dumas, R. Aissaoui, and J. A. De Guise, \"A 3D generic inverse dynamic method using wrench notation and quaternion algebra,\u201d Comput Meth Biomech Biomed Eng, vol. 7, no. 3, pp. 159\u2013166, 2004. The results are the forces and moments applied by the distal segment on the proximal articulation, in the global coordinates system. The state of this module is \"Tested, but still not validated\". To date, the following tests were made and were successful: A complete loop from the point of force application point to the force point application, using real wheelchair propulsion data, with a fake mass of 0 kg. In these test conditions, the proximal and distal kinetics are equal, as expected. This test was to verify that the implemented matrices are exempt of sign errors. Real wheelchair propulsion data was inspected and seems plausible. import ktk Loading sample data In this tutorial, we will load propulsion data from a sprint in Wheelchair Basketball. Kinetics were recorded using an instrumented wheel (SmartWheel) and kinematics were recorded using an optoelectronic system (Optitrack). Data were preprocessed in Matlab. # Total mass of the participant total_mass = 75 # Load kinetics kinetics = ktk . loadmat ( 'data/inversedynamics/basketball_kinetics.mat' ) kinetics = kinetics [ 'kineticsSWR' ] # Correct the signs so that the moments are in a correct coordinate system # (The SmartWheel usually reports Mz positive when it should be negative) kinetics . data [ 'Moments' ][:, 2 ] = - kinetics . data [ 'Moments' ][:, 2 ] # Load kinematics kinematics = ktk . loadmat ( 'data/inversedynamics/basketball_kinematics.mat' ) kinematics = kinematics [ 'kinematics' ] markers = kinematics [ 'Markers' ] # Sync kinetics and kinematics (there is a 5.525 time lag between both) markers . time -= 5.525 # Merge all under the same ts_all TimeSeries. ts_all = markers . copy () ts_all . merge ( kinetics , resample = True ) # Keep only the sprint data ts_all = ts_all . get_ts_between_times ( 0 , 15 ) Calculate the force and moments at the hand The same calculation is done on every segment, from distal to proximal. We begin with the segment 'Wheel', since the kinetics are measured at the wheel, and we go up to the hand, which will later be the new point of force application. We will ignore the inertial parameters of the pushrim. pushrim_inertial_parameters = { 'Mass' : 0 , 'COMProximalRatio' : 0 , 'GyrationCOMRatio' : 0 } ts = ktk . TimeSeries ( time = ts_all . time ) ts . data [ 'ProximalJointPosition' ] = ts_all . data [ 'BodyR_HandR' ] ts . data [ 'DistalJointPosition' ] = ts_all . data [ 'RearWheelCenterR' ] ts . data [ 'ForceApplicationPosition' ] = ts_all . data [ 'RearWheelCenterR' ] ts . data [ 'DistalForces' ] = ts_all . data [ 'Forces' ] ts . data [ 'DistalMoments' ] = ts_all . data [ 'Moments' ] new_ts = ktk . inversedynamics . calculate_proximal_wrench ( ts , pushrim_inertial_parameters ) # Print the results new_ts . plot ([ 'DistalForces' , 'DistalMoments' ]) new_ts . plot ([ 'ProximalForces' , 'ProximalMoments' ]) /Users/felix/Documents/Recherche/kineticstoolkit/ktk/filters.py:72: UserWarning: NaNs found in the signal. They have been interpolated before filtering, and then put back in the filtered data. warnings.warn(warning_message) Calculate the force and moments at the elbow ts = ktk . TimeSeries ( time = ts_all . time ) ts . data [ 'ProximalJointPosition' ] = ts_all . data [ 'ElbowR' ] ts . data [ 'DistalJointPosition' ] = ts_all . data [ 'RadialStyloidR' ] ts . data [ 'ForceApplicationPosition' ] = ts_all . data [ 'BodyR_HandR' ] ts . data [ 'DistalForces' ] = new_ts . data [ 'ProximalForces' ] ts . data [ 'DistalMoments' ] = new_ts . data [ 'ProximalMoments' ] new_ts = ktk . inversedynamics . calculate_proximal_wrench ( ts , ktk . inversedynamics . get_anthropometrics ( 'ForearmHand' , total_mass )) # Print the results new_ts . plot ([ 'DistalForces' , 'DistalMoments' ]) new_ts . plot ([ 'ProximalForces' , 'ProximalMoments' ]) /Users/felix/Documents/Recherche/kineticstoolkit/ktk/filters.py:72: UserWarning: NaNs found in the signal. They have been interpolated before filtering, and then put back in the filtered data. warnings.warn(warning_message) Calculate the force and moments at the shoulder ts = ktk . TimeSeries ( time = ts_all . time ) ts . data [ 'ProximalJointPosition' ] = ts_all . data [ 'BodyR_AcromionR' ] ts . data [ 'DistalJointPosition' ] = ts_all . data [ 'ElbowR' ] ts . data [ 'ForceApplicationPosition' ] = ts_all . data [ 'ElbowR' ] ts . data [ 'DistalForces' ] = new_ts . data [ 'ProximalForces' ] ts . data [ 'DistalMoments' ] = new_ts . data [ 'ProximalMoments' ] new_ts = ktk . inversedynamics . calculate_proximal_wrench ( ts , ktk . inversedynamics . get_anthropometrics ( 'UpperArm' , total_mass )) # Print the results new_ts . plot ([ 'DistalForces' , 'DistalMoments' ]) new_ts . plot ([ 'ProximalForces' , 'ProximalMoments' ]) /Users/felix/Documents/Recherche/kineticstoolkit/ktk/filters.py:72: UserWarning: NaNs found in the signal. They have been interpolated before filtering, and then put back in the filtered data. warnings.warn(warning_message)","title":"Inverse dynamics"},{"location":"inversedynamics.html#inverse-dynamics","text":"The inversedynamics calculates the proximal forces and moments based on the segment's kinematics and distal forces and moments, based on the general method published in: Cite R. Dumas, R. Aissaoui, and J. A. De Guise, \"A 3D generic inverse dynamic method using wrench notation and quaternion algebra,\u201d Comput Meth Biomech Biomed Eng, vol. 7, no. 3, pp. 159\u2013166, 2004. The results are the forces and moments applied by the distal segment on the proximal articulation, in the global coordinates system. The state of this module is \"Tested, but still not validated\". To date, the following tests were made and were successful: A complete loop from the point of force application point to the force point application, using real wheelchair propulsion data, with a fake mass of 0 kg. In these test conditions, the proximal and distal kinetics are equal, as expected. This test was to verify that the implemented matrices are exempt of sign errors. Real wheelchair propulsion data was inspected and seems plausible. import ktk","title":"Inverse Dynamics"},{"location":"inversedynamics.html#loading-sample-data","text":"In this tutorial, we will load propulsion data from a sprint in Wheelchair Basketball. Kinetics were recorded using an instrumented wheel (SmartWheel) and kinematics were recorded using an optoelectronic system (Optitrack). Data were preprocessed in Matlab. # Total mass of the participant total_mass = 75 # Load kinetics kinetics = ktk . loadmat ( 'data/inversedynamics/basketball_kinetics.mat' ) kinetics = kinetics [ 'kineticsSWR' ] # Correct the signs so that the moments are in a correct coordinate system # (The SmartWheel usually reports Mz positive when it should be negative) kinetics . data [ 'Moments' ][:, 2 ] = - kinetics . data [ 'Moments' ][:, 2 ] # Load kinematics kinematics = ktk . loadmat ( 'data/inversedynamics/basketball_kinematics.mat' ) kinematics = kinematics [ 'kinematics' ] markers = kinematics [ 'Markers' ] # Sync kinetics and kinematics (there is a 5.525 time lag between both) markers . time -= 5.525 # Merge all under the same ts_all TimeSeries. ts_all = markers . copy () ts_all . merge ( kinetics , resample = True ) # Keep only the sprint data ts_all = ts_all . get_ts_between_times ( 0 , 15 )","title":"Loading sample data"},{"location":"inversedynamics.html#calculate-the-force-and-moments-at-the-hand","text":"The same calculation is done on every segment, from distal to proximal. We begin with the segment 'Wheel', since the kinetics are measured at the wheel, and we go up to the hand, which will later be the new point of force application. We will ignore the inertial parameters of the pushrim. pushrim_inertial_parameters = { 'Mass' : 0 , 'COMProximalRatio' : 0 , 'GyrationCOMRatio' : 0 } ts = ktk . TimeSeries ( time = ts_all . time ) ts . data [ 'ProximalJointPosition' ] = ts_all . data [ 'BodyR_HandR' ] ts . data [ 'DistalJointPosition' ] = ts_all . data [ 'RearWheelCenterR' ] ts . data [ 'ForceApplicationPosition' ] = ts_all . data [ 'RearWheelCenterR' ] ts . data [ 'DistalForces' ] = ts_all . data [ 'Forces' ] ts . data [ 'DistalMoments' ] = ts_all . data [ 'Moments' ] new_ts = ktk . inversedynamics . calculate_proximal_wrench ( ts , pushrim_inertial_parameters ) # Print the results new_ts . plot ([ 'DistalForces' , 'DistalMoments' ]) new_ts . plot ([ 'ProximalForces' , 'ProximalMoments' ]) /Users/felix/Documents/Recherche/kineticstoolkit/ktk/filters.py:72: UserWarning: NaNs found in the signal. They have been interpolated before filtering, and then put back in the filtered data. warnings.warn(warning_message)","title":"Calculate the force and moments at the hand"},{"location":"inversedynamics.html#calculate-the-force-and-moments-at-the-elbow","text":"ts = ktk . TimeSeries ( time = ts_all . time ) ts . data [ 'ProximalJointPosition' ] = ts_all . data [ 'ElbowR' ] ts . data [ 'DistalJointPosition' ] = ts_all . data [ 'RadialStyloidR' ] ts . data [ 'ForceApplicationPosition' ] = ts_all . data [ 'BodyR_HandR' ] ts . data [ 'DistalForces' ] = new_ts . data [ 'ProximalForces' ] ts . data [ 'DistalMoments' ] = new_ts . data [ 'ProximalMoments' ] new_ts = ktk . inversedynamics . calculate_proximal_wrench ( ts , ktk . inversedynamics . get_anthropometrics ( 'ForearmHand' , total_mass )) # Print the results new_ts . plot ([ 'DistalForces' , 'DistalMoments' ]) new_ts . plot ([ 'ProximalForces' , 'ProximalMoments' ]) /Users/felix/Documents/Recherche/kineticstoolkit/ktk/filters.py:72: UserWarning: NaNs found in the signal. They have been interpolated before filtering, and then put back in the filtered data. warnings.warn(warning_message)","title":"Calculate the force and moments at the elbow"},{"location":"inversedynamics.html#calculate-the-force-and-moments-at-the-shoulder","text":"ts = ktk . TimeSeries ( time = ts_all . time ) ts . data [ 'ProximalJointPosition' ] = ts_all . data [ 'BodyR_AcromionR' ] ts . data [ 'DistalJointPosition' ] = ts_all . data [ 'ElbowR' ] ts . data [ 'ForceApplicationPosition' ] = ts_all . data [ 'ElbowR' ] ts . data [ 'DistalForces' ] = new_ts . data [ 'ProximalForces' ] ts . data [ 'DistalMoments' ] = new_ts . data [ 'ProximalMoments' ] new_ts = ktk . inversedynamics . calculate_proximal_wrench ( ts , ktk . inversedynamics . get_anthropometrics ( 'UpperArm' , total_mass )) # Print the results new_ts . plot ([ 'DistalForces' , 'DistalMoments' ]) new_ts . plot ([ 'ProximalForces' , 'ProximalMoments' ]) /Users/felix/Documents/Recherche/kineticstoolkit/ktk/filters.py:72: UserWarning: NaNs found in the signal. They have been interpolated before filtering, and then put back in the filtered data. warnings.warn(warning_message)","title":"Calculate the force and moments at the shoulder"},{"location":"kinematics.html","text":"Kinematics The kinematics module allows opening trajectories of markers from c3d or n3d files, and process those trajectory to: - create rigid body configurations based on a static acquisitions; - register the markers trajectories to rigid body trajectories; - create virtual marker configuration based on probing acquisitions; - reconstruct these virtual markers from rigid body trajectories; - and other operations that will be implemented in the future. Here is a quick example of how to reconstruct complete kinematics during a task, based on a static acquisition and probing acquisitions. import ktk import numpy as np Loading a c3d or n3d file The kinematics module provide the methods read_c3d_file and read_n3d_file to read files generated by common motion capture devices. Reading c3d files is provided by the external ezc3d module; see the Installing section for information on how to install ezc3d . In this tutorial, we will read a n3d file generated by an Optotrak system. # Names of the markers labels = [ 'Probe1' , 'Probe2' , 'Probe3' , 'Probe4' , 'Probe5' , 'Probe6' , 'WheelchairRearR' , 'WheelchairRearL' , 'WheelchairFront' , 'ScapulaL1' , 'ScapulaL2' , 'ScapulaL3' , 'ScapulaR1' , 'ScapulaR2' , 'ScapulaR3' , 'Head1' , 'Head2' , 'Head3' , 'Sternum' , 'ArmL1' , 'ArmL2' , 'ArmL3' , 'LateralEpicondyleL' , 'ForearmL1' , 'ForearmL2' , 'ForearmL3' , 'NAG' , 'GloveL1' , 'GloveL2' , 'GloveL3' , 'ArmR1' , 'ArmR2' , 'ArmR3' , 'LateralEpicondyleR' , 'ForearmR1' , 'ForearmR2' , 'ForearmR3' , 'NAR' , 'GloveR1' , 'GloveR2' , 'GloveR3' ] markers = ktk . kinematics . read_n3d_file ( 'data/kinematics/sample_static.n3d' , labels = labels ) markers TimeSeries with attributes: data: <dict with 41 entries>, data_info: <dict with 41 entries>, events: <list of 0 items>, time: <array of shape (700,)>, time_info: <dict with 1 entries> Each data key corresponds to the trajectory of one marker: markers . data { 'ArmL1': <array of shape (700, 4)>, 'ArmL2': <array of shape (700, 4)>, 'ArmL3': <array of shape (700, 4)>, 'ArmR1': <array of shape (700, 4)>, 'ArmR2': <array of shape (700, 4)>, 'ArmR3': <array of shape (700, 4)>, 'ForearmL1': <array of shape (700, 4)>, 'ForearmL2': <array of shape (700, 4)>, 'ForearmL3': <array of shape (700, 4)>, 'ForearmR1': <array of shape (700, 4)>, 'ForearmR2': <array of shape (700, 4)>, 'ForearmR3': <array of shape (700, 4)>, 'GloveL1': <array of shape (700, 4)>, 'GloveL2': <array of shape (700, 4)>, 'GloveL3': <array of shape (700, 4)>, 'GloveR1': <array of shape (700, 4)>, 'GloveR2': <array of shape (700, 4)>, 'GloveR3': <array of shape (700, 4)>, 'Head1': <array of shape (700, 4)>, 'Head2': <array of shape (700, 4)>, 'Head3': <array of shape (700, 4)>, 'LateralEpicondyleL': <array of shape (700, 4)>, 'LateralEpicondyleR': <array of shape (700, 4)>, 'NAG': <array of shape (700, 4)>, 'NAR': <array of shape (700, 4)>, 'Probe1': <array of shape (700, 4)>, 'Probe2': <array of shape (700, 4)>, 'Probe3': <array of shape (700, 4)>, 'Probe4': <array of shape (700, 4)>, 'Probe5': <array of shape (700, 4)>, 'Probe6': <array of shape (700, 4)>, 'ScapulaL1': <array of shape (700, 4)>, 'ScapulaL2': <array of shape (700, 4)>, 'ScapulaL3': <array of shape (700, 4)>, 'ScapulaR1': <array of shape (700, 4)>, 'ScapulaR2': <array of shape (700, 4)>, 'ScapulaR3': <array of shape (700, 4)>, 'Sternum': <array of shape (700, 4)>, 'WheelchairFront': <array of shape (700, 4)>, 'WheelchairRearL': <array of shape (700, 4)>, 'WheelchairRearR': <array of shape (700, 4)> } Visualizing the markers The Player class is a matplotlib based user interface to visualize markers, rigid bodies and segments in three dimensions. It is important to select an interactive IPython's GUI front-end, or the Player's figure will simply print out without being interactive. See the Installing section for more information. ktk . Player ( markers ) <ktk.player.Player at 0x7fdc09aaf750> Reconstructing kinematics Defining rigid body configurations using a static acquisition One of the aims of the static trial is to have a sample where every marker is visible. We use this trial to define the rigid body configuration. A rigid body configuration is a list of markers that form a rigid body, along with their local position in the rigid body's reference frame. For this example, we will create rigid bodies for the markers triads 'ArmR' and 'ForearmR'. config = dict () # Will contain all configuration data. config [ 'RigidBodies' ] = dict () # Will contain all rigid body configurations. # Read the static trial markers = ktk . kinematics . read_n3d_file ( 'data/kinematics/sample_static.n3d' , labels = labels ) # Show this trial, just to inspect it ktk . Player ( markers , zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc09aaf690> # Create the rigid body configurations config [ 'RigidBodies' ][ 'ArmR' ] = ktk . kinematics . create_rigid_body_config ( markers , [ 'ArmR1' , 'ArmR2' , 'ArmR3' ]) config [ 'RigidBodies' ][ 'ForearmR' ] = ktk . kinematics . create_rigid_body_config ( markers , [ 'ForearmR1' , 'ForearmR2' , 'ForearmR3' ]) The probe's rigid body configuration is created manually from its specifications. Each local point is expressed relative to a reference frame that is centered at the probe's tip. config [ 'RigidBodies' ][ 'Probe' ] = { 'MarkerNames' : [ 'Probe1' , 'Probe2' , 'Probe3' , 'Probe4' , 'Probe5' , 'Probe6' ], 'LocalPoints' : np . array ([[ [ 2.1213 , 2.1213 , 2.0575 , 2.1213 , 1.7070 , 1.7762 ], [ - 15.8328 , 15.8508 , 16.0096 , 16.1204 , - 15.5780 , - 15.6057 ], [ 86.4285 , 86.4285 , 130.9445 , 175.4395 , 175.3805 , 130.8888 ], [ 1000 , 1000 , 1000 , 1000 , 1000 , 1000 ]]] ) / 1000 } Defining the virtual marker configurations based on probing acquisitions config [ 'VirtualMarkers' ] = dict () # Will contain all virtual marker configurations Since this is a repetitive operation, we will create a new function that will be called for each virtual marker: def process_probing_acquisition ( file_name , rigid_body_name ): # Load the markers markers = ktk . kinematics . read_n3d_file ( file_name , labels = labels ) # Calculate rigid body trajectories using these markers rigid_bodies = ktk . kinematics . register_markers ( markers , config [ 'RigidBodies' ]) # Add the marker 'ProbeTip' in markers. This is the origin of the Probe # rigid body. markers . data [ 'ProbeTip' ] = rigid_bodies . data [ 'Probe' ][:, :, 3 ] markers . add_data_info ( 'ProbeTip' , 'Color' , 'r' ) # Create the marker configuration return ktk . kinematics . create_virtual_marker_config ( markers , rigid_bodies , 'ProbeTip' , rigid_body_name ) Now, we can process every probing acquisition. config [ 'VirtualMarkers' ][ 'AcromionR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_acromion_R.n3d' , 'ArmR' ) config [ 'VirtualMarkers' ][ 'MedialEpicondyleR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_medial_epicondyle_R.n3d' , 'ArmR' ) config [ 'VirtualMarkers' ][ 'OlecraneR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_olecrane_R.n3d' , 'ForearmR' ) config [ 'VirtualMarkers' ][ 'RadialStyloidR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_radial_styloid_R.n3d' , 'ForearmR' ) config [ 'VirtualMarkers' ][ 'UlnarStyloidR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_ulnar_styloid_R.n3d' , 'ForearmR' ) Defining segment configurations This step is purely for visualization. Here, we define different segments that will be shown in the Player. config [ 'Segments' ] = dict () # Will contain all segment definitions config [ 'Segments' ][ 'ArmR' ] = { 'Color' : [ 1 , 0.25 , 0 ], 'Links' : [[ 'AcromionR' , 'MedialEpicondyleR' ], [ 'AcromionR' , 'LateralEpicondyleR' ], [ 'AcromionR' , 'OlecraneR' ]] } config [ 'Segments' ][ 'ForearmR' ] = { 'Color' : [ 1 , 0.5 , 0 ], 'Links' : [[ 'MedialEpicondyleR' , 'RadialStyloidR' ], [ 'MedialEpicondyleR' , 'UlnarStyloidR' ], [ 'LateralEpicondyleR' , 'RadialStyloidR' ], [ 'LateralEpicondyleR' , 'UlnarStyloidR' ], [ 'OlecraneR' , 'RadialStyloidR' ], [ 'OlecraneR' , 'UlnarStyloidR' ], [ 'UlnarStyloidR' , 'RadialStyloidR' ]] } Processing an experimental trial Now that we configured the rigid bodies and the virtual markers, we are ready to load an experimental trial, calculate the rigid body trajectories and recreate the virtual markers using these rigid bodies. # Load the markers of the experimental trial markers = ktk . kinematics . read_n3d_file ( 'data/kinematics/sample_propulsion.n3d' , labels = labels ) # Show those markers in a player ktk . Player ( markers , zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc09fd2610> # Compute the rigid body trajectories rigid_bodies = ktk . kinematics . register_markers ( markers , config [ 'RigidBodies' ]) # Show those rigid bodies and markers in a player ktk . Player ( markers , rigid_bodies , zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc09fe3990> # Add the virtual markers for virtual_marker in config [ 'VirtualMarkers' ]: local_coordinates = config [ 'VirtualMarkers' ][ virtual_marker ][ 'LocalPoint' ] rigid_body_name = config [ 'VirtualMarkers' ][ virtual_marker ][ 'RigidBodyName' ] reference_frame = rigid_bodies . data [ rigid_body_name ] markers . data [ virtual_marker ] = ktk . geometry . get_global_coordinates ( local_coordinates , reference_frame ) # Assign a color for these virtual markers markers . add_data_info ( virtual_marker , 'Color' , 'c' ) # Show the markers and rigid bodies in a player ktk . Player ( markers , rigid_bodies , zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc0d20d810> # Add the segments ktk . Player ( markers , segments = config [ 'Segments' ], zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc0ec0c6d0>","title":"Kinematics"},{"location":"kinematics.html#kinematics","text":"The kinematics module allows opening trajectories of markers from c3d or n3d files, and process those trajectory to: - create rigid body configurations based on a static acquisitions; - register the markers trajectories to rigid body trajectories; - create virtual marker configuration based on probing acquisitions; - reconstruct these virtual markers from rigid body trajectories; - and other operations that will be implemented in the future. Here is a quick example of how to reconstruct complete kinematics during a task, based on a static acquisition and probing acquisitions. import ktk import numpy as np","title":"Kinematics"},{"location":"kinematics.html#loading-a-c3d-or-n3d-file","text":"The kinematics module provide the methods read_c3d_file and read_n3d_file to read files generated by common motion capture devices. Reading c3d files is provided by the external ezc3d module; see the Installing section for information on how to install ezc3d . In this tutorial, we will read a n3d file generated by an Optotrak system. # Names of the markers labels = [ 'Probe1' , 'Probe2' , 'Probe3' , 'Probe4' , 'Probe5' , 'Probe6' , 'WheelchairRearR' , 'WheelchairRearL' , 'WheelchairFront' , 'ScapulaL1' , 'ScapulaL2' , 'ScapulaL3' , 'ScapulaR1' , 'ScapulaR2' , 'ScapulaR3' , 'Head1' , 'Head2' , 'Head3' , 'Sternum' , 'ArmL1' , 'ArmL2' , 'ArmL3' , 'LateralEpicondyleL' , 'ForearmL1' , 'ForearmL2' , 'ForearmL3' , 'NAG' , 'GloveL1' , 'GloveL2' , 'GloveL3' , 'ArmR1' , 'ArmR2' , 'ArmR3' , 'LateralEpicondyleR' , 'ForearmR1' , 'ForearmR2' , 'ForearmR3' , 'NAR' , 'GloveR1' , 'GloveR2' , 'GloveR3' ] markers = ktk . kinematics . read_n3d_file ( 'data/kinematics/sample_static.n3d' , labels = labels ) markers TimeSeries with attributes: data: <dict with 41 entries>, data_info: <dict with 41 entries>, events: <list of 0 items>, time: <array of shape (700,)>, time_info: <dict with 1 entries> Each data key corresponds to the trajectory of one marker: markers . data { 'ArmL1': <array of shape (700, 4)>, 'ArmL2': <array of shape (700, 4)>, 'ArmL3': <array of shape (700, 4)>, 'ArmR1': <array of shape (700, 4)>, 'ArmR2': <array of shape (700, 4)>, 'ArmR3': <array of shape (700, 4)>, 'ForearmL1': <array of shape (700, 4)>, 'ForearmL2': <array of shape (700, 4)>, 'ForearmL3': <array of shape (700, 4)>, 'ForearmR1': <array of shape (700, 4)>, 'ForearmR2': <array of shape (700, 4)>, 'ForearmR3': <array of shape (700, 4)>, 'GloveL1': <array of shape (700, 4)>, 'GloveL2': <array of shape (700, 4)>, 'GloveL3': <array of shape (700, 4)>, 'GloveR1': <array of shape (700, 4)>, 'GloveR2': <array of shape (700, 4)>, 'GloveR3': <array of shape (700, 4)>, 'Head1': <array of shape (700, 4)>, 'Head2': <array of shape (700, 4)>, 'Head3': <array of shape (700, 4)>, 'LateralEpicondyleL': <array of shape (700, 4)>, 'LateralEpicondyleR': <array of shape (700, 4)>, 'NAG': <array of shape (700, 4)>, 'NAR': <array of shape (700, 4)>, 'Probe1': <array of shape (700, 4)>, 'Probe2': <array of shape (700, 4)>, 'Probe3': <array of shape (700, 4)>, 'Probe4': <array of shape (700, 4)>, 'Probe5': <array of shape (700, 4)>, 'Probe6': <array of shape (700, 4)>, 'ScapulaL1': <array of shape (700, 4)>, 'ScapulaL2': <array of shape (700, 4)>, 'ScapulaL3': <array of shape (700, 4)>, 'ScapulaR1': <array of shape (700, 4)>, 'ScapulaR2': <array of shape (700, 4)>, 'ScapulaR3': <array of shape (700, 4)>, 'Sternum': <array of shape (700, 4)>, 'WheelchairFront': <array of shape (700, 4)>, 'WheelchairRearL': <array of shape (700, 4)>, 'WheelchairRearR': <array of shape (700, 4)> }","title":"Loading a c3d or n3d file"},{"location":"kinematics.html#visualizing-the-markers","text":"The Player class is a matplotlib based user interface to visualize markers, rigid bodies and segments in three dimensions. It is important to select an interactive IPython's GUI front-end, or the Player's figure will simply print out without being interactive. See the Installing section for more information. ktk . Player ( markers ) <ktk.player.Player at 0x7fdc09aaf750>","title":"Visualizing the markers"},{"location":"kinematics.html#reconstructing-kinematics","text":"","title":"Reconstructing kinematics"},{"location":"kinematics.html#defining-rigid-body-configurations-using-a-static-acquisition","text":"One of the aims of the static trial is to have a sample where every marker is visible. We use this trial to define the rigid body configuration. A rigid body configuration is a list of markers that form a rigid body, along with their local position in the rigid body's reference frame. For this example, we will create rigid bodies for the markers triads 'ArmR' and 'ForearmR'. config = dict () # Will contain all configuration data. config [ 'RigidBodies' ] = dict () # Will contain all rigid body configurations. # Read the static trial markers = ktk . kinematics . read_n3d_file ( 'data/kinematics/sample_static.n3d' , labels = labels ) # Show this trial, just to inspect it ktk . Player ( markers , zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc09aaf690> # Create the rigid body configurations config [ 'RigidBodies' ][ 'ArmR' ] = ktk . kinematics . create_rigid_body_config ( markers , [ 'ArmR1' , 'ArmR2' , 'ArmR3' ]) config [ 'RigidBodies' ][ 'ForearmR' ] = ktk . kinematics . create_rigid_body_config ( markers , [ 'ForearmR1' , 'ForearmR2' , 'ForearmR3' ]) The probe's rigid body configuration is created manually from its specifications. Each local point is expressed relative to a reference frame that is centered at the probe's tip. config [ 'RigidBodies' ][ 'Probe' ] = { 'MarkerNames' : [ 'Probe1' , 'Probe2' , 'Probe3' , 'Probe4' , 'Probe5' , 'Probe6' ], 'LocalPoints' : np . array ([[ [ 2.1213 , 2.1213 , 2.0575 , 2.1213 , 1.7070 , 1.7762 ], [ - 15.8328 , 15.8508 , 16.0096 , 16.1204 , - 15.5780 , - 15.6057 ], [ 86.4285 , 86.4285 , 130.9445 , 175.4395 , 175.3805 , 130.8888 ], [ 1000 , 1000 , 1000 , 1000 , 1000 , 1000 ]]] ) / 1000 }","title":"Defining rigid body configurations using a static acquisition"},{"location":"kinematics.html#defining-the-virtual-marker-configurations-based-on-probing-acquisitions","text":"config [ 'VirtualMarkers' ] = dict () # Will contain all virtual marker configurations Since this is a repetitive operation, we will create a new function that will be called for each virtual marker: def process_probing_acquisition ( file_name , rigid_body_name ): # Load the markers markers = ktk . kinematics . read_n3d_file ( file_name , labels = labels ) # Calculate rigid body trajectories using these markers rigid_bodies = ktk . kinematics . register_markers ( markers , config [ 'RigidBodies' ]) # Add the marker 'ProbeTip' in markers. This is the origin of the Probe # rigid body. markers . data [ 'ProbeTip' ] = rigid_bodies . data [ 'Probe' ][:, :, 3 ] markers . add_data_info ( 'ProbeTip' , 'Color' , 'r' ) # Create the marker configuration return ktk . kinematics . create_virtual_marker_config ( markers , rigid_bodies , 'ProbeTip' , rigid_body_name ) Now, we can process every probing acquisition. config [ 'VirtualMarkers' ][ 'AcromionR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_acromion_R.n3d' , 'ArmR' ) config [ 'VirtualMarkers' ][ 'MedialEpicondyleR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_medial_epicondyle_R.n3d' , 'ArmR' ) config [ 'VirtualMarkers' ][ 'OlecraneR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_olecrane_R.n3d' , 'ForearmR' ) config [ 'VirtualMarkers' ][ 'RadialStyloidR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_radial_styloid_R.n3d' , 'ForearmR' ) config [ 'VirtualMarkers' ][ 'UlnarStyloidR' ] = process_probing_acquisition ( 'data/kinematics/sample_probing_ulnar_styloid_R.n3d' , 'ForearmR' )","title":"Defining the virtual marker configurations based on probing acquisitions"},{"location":"kinematics.html#defining-segment-configurations","text":"This step is purely for visualization. Here, we define different segments that will be shown in the Player. config [ 'Segments' ] = dict () # Will contain all segment definitions config [ 'Segments' ][ 'ArmR' ] = { 'Color' : [ 1 , 0.25 , 0 ], 'Links' : [[ 'AcromionR' , 'MedialEpicondyleR' ], [ 'AcromionR' , 'LateralEpicondyleR' ], [ 'AcromionR' , 'OlecraneR' ]] } config [ 'Segments' ][ 'ForearmR' ] = { 'Color' : [ 1 , 0.5 , 0 ], 'Links' : [[ 'MedialEpicondyleR' , 'RadialStyloidR' ], [ 'MedialEpicondyleR' , 'UlnarStyloidR' ], [ 'LateralEpicondyleR' , 'RadialStyloidR' ], [ 'LateralEpicondyleR' , 'UlnarStyloidR' ], [ 'OlecraneR' , 'RadialStyloidR' ], [ 'OlecraneR' , 'UlnarStyloidR' ], [ 'UlnarStyloidR' , 'RadialStyloidR' ]] }","title":"Defining segment configurations"},{"location":"kinematics.html#processing-an-experimental-trial","text":"Now that we configured the rigid bodies and the virtual markers, we are ready to load an experimental trial, calculate the rigid body trajectories and recreate the virtual markers using these rigid bodies. # Load the markers of the experimental trial markers = ktk . kinematics . read_n3d_file ( 'data/kinematics/sample_propulsion.n3d' , labels = labels ) # Show those markers in a player ktk . Player ( markers , zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc09fd2610> # Compute the rigid body trajectories rigid_bodies = ktk . kinematics . register_markers ( markers , config [ 'RigidBodies' ]) # Show those rigid bodies and markers in a player ktk . Player ( markers , rigid_bodies , zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc09fe3990> # Add the virtual markers for virtual_marker in config [ 'VirtualMarkers' ]: local_coordinates = config [ 'VirtualMarkers' ][ virtual_marker ][ 'LocalPoint' ] rigid_body_name = config [ 'VirtualMarkers' ][ virtual_marker ][ 'RigidBodyName' ] reference_frame = rigid_bodies . data [ rigid_body_name ] markers . data [ virtual_marker ] = ktk . geometry . get_global_coordinates ( local_coordinates , reference_frame ) # Assign a color for these virtual markers markers . add_data_info ( virtual_marker , 'Color' , 'c' ) # Show the markers and rigid bodies in a player ktk . Player ( markers , rigid_bodies , zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc0d20d810> # Add the segments ktk . Player ( markers , segments = config [ 'Segments' ], zoom = 2 , azimuth = 0.8 , elevation = 0.16 , translation = ( 0.2 , - 0.7 )) <ktk.player.Player at 0x7fdc0ec0c6d0>","title":"Processing an experimental trial"},{"location":"pushrimkinetics.html","text":"Pushrim Kinetics The pushrimkinetics module allows processing kinetics data from instrumented wheelchair wheels such as the SmartWheel. import ktk import matplotlib.pyplot as plt Read data from file The first step is to load data from a file, using the read_file function. filename = ( 'data/pushrimkinetics/' 'sample_swl_overground_propulsion_withrubber.csv' ) kinetics = ktk . pushrimkinetics . read_file ( filename ) Let see what we loaded: kinetics TimeSeries with attributes: data: <dict with 5 entries>, data_info: <dict with 4 entries>, events: <list of 0 items>, time: <array of shape (7682,)>, time_info: <dict with 1 entries> kinetics . data { 'Angle': <array of shape (7682,)>, 'Channels': <array of shape (7682, 6)>, 'Forces': <array of shape (7682, 4)>, 'Index': <array of shape (7682,)>, 'Moments': <array of shape (7682, 4)> } plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' ) Calculate forces and moments If the data is not in a CSV form but instead in a TXT file from the SmartWheel's SD card, we can also read this file, by specifying the smartwheeltxt format in read_file . However, in this case, the file contains only the raw channels, index and angle. In this case, we must calculate the forces and moments based on a calibration matrix. The function calculate_forces_and_moments does this calculation and already includes calibration matrices based on SmartWheels' serial numbers. For example: new_kinetics = ktk . pushrimkinetics . calculate_forces_and_moments ( kinetics , 'LIO-123' ) plt . subplot ( 2 , 1 , 1 ) new_kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) new_kinetics . plot ( 'Moments' ) When the forces and moments are reconstructed from raw data, no modification has been applied on the signals by the SmartWheel software to account for wheel side. Therefore some signals may be inverted, as observed here. Removing sinusoids in forces and moments We observe in the last graphs that sinusoidal offsets are presents mostly in the forces but also in the moments. We can auto-remove these offsets using remove_sinusoids . Let's apply this function on the data we just loaded. kinetics = ktk . pushrimkinetics . remove_sinusoids ( kinetics ) plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' ) This automatic method has only be validated for straight-line, level-ground propulsion. For any other condition, a baseline trial is required. A baseline trial is a trial where an operator pushes the wheelchair but no external force appart from gravity is applied on the instrumented wheel. For example: kinetics = ktk . pushrimkinetics . read_file ( 'data/pushrimkinetics/sample_swl_overground_propulsion_withrubber.csv' ) baseline = ktk . pushrimkinetics . read_file ( 'data/pushrimkinetics/sample_swl_overground_baseline_withrubber.csv' ) kinetics = ktk . pushrimkinetics . remove_sinusoids ( kinetics , baseline ) plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' ) Calculate velocity and power Thee wheel velocity is calculated from the wheel angle with a derivative Savitsky-Golay filter, using the calculate_velocity function. Once the velocity has been calculated, the output power can also be calculated by multiplying the velocity by the propulsion moment, using the calculate_power function. kinetics = ktk . pushrimkinetics . calculate_velocity ( kinetics ) kinetics = ktk . pushrimkinetics . calculate_power ( kinetics ) kinetics . plot ([ 'Velocity' , 'Power' ]) Detecting pushes The function detect_pushes allows detecting pushes and recoveries automatically based on a double-threshold. kinetics = ktk . pushrimkinetics . detect_pushes ( kinetics ) kinetics TimeSeries with attributes: data: <dict with 7 entries>, data_info: <dict with 6 entries>, events: <list of 50 items>, time: <array of shape (7682,)>, time_info: <dict with 1 entries> We see that the TimeSeries now has 52 events. Let's see these events on a plot. plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' ) Time-normalizing data Now, we may be intested in time-normalizing our pushes. For example, if we are interested to find the average progression of the push force. Time-normalizing is not specific to the ktk.pushrimkinetics module, it is in the ktk.cycles module. To analyze the push phase, we want to time-normalize each push from the push event to the recovery event. kinetics = ktk . cycles . time_normalize ( kinetics , 'push' , 'recovery' ) plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' ) It is now possible to extract each push in a i_cycle x i_percent x i_component form, using the ktk.cycles.get_reshaped_time_normalized_data method. data = ktk . cycles . get_reshaped_time_normalized_data ( kinetics ) data { 'Angle': <array of shape (25, 100)>, 'Channels': <array of shape (25, 100, 6)>, 'Forces': <array of shape (25, 100, 4)>, 'Index': <array of shape (25, 100)>, 'Moments': <array of shape (25, 100, 4)>, 'Power': <array of shape (25, 100)>, 'Velocity': <array of shape (25, 100)> } Plot the normalized force curves one on top of each other: for i in range ( data [ 'Forces' ] . shape [ 0 ]): plt . plot ( data [ 'Forces' ][ i ])","title":"Pushrim Kinetics"},{"location":"pushrimkinetics.html#pushrim-kinetics","text":"The pushrimkinetics module allows processing kinetics data from instrumented wheelchair wheels such as the SmartWheel. import ktk import matplotlib.pyplot as plt","title":"Pushrim Kinetics"},{"location":"pushrimkinetics.html#read-data-from-file","text":"The first step is to load data from a file, using the read_file function. filename = ( 'data/pushrimkinetics/' 'sample_swl_overground_propulsion_withrubber.csv' ) kinetics = ktk . pushrimkinetics . read_file ( filename ) Let see what we loaded: kinetics TimeSeries with attributes: data: <dict with 5 entries>, data_info: <dict with 4 entries>, events: <list of 0 items>, time: <array of shape (7682,)>, time_info: <dict with 1 entries> kinetics . data { 'Angle': <array of shape (7682,)>, 'Channels': <array of shape (7682, 6)>, 'Forces': <array of shape (7682, 4)>, 'Index': <array of shape (7682,)>, 'Moments': <array of shape (7682, 4)> } plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' )","title":"Read data from file"},{"location":"pushrimkinetics.html#calculate-forces-and-moments","text":"If the data is not in a CSV form but instead in a TXT file from the SmartWheel's SD card, we can also read this file, by specifying the smartwheeltxt format in read_file . However, in this case, the file contains only the raw channels, index and angle. In this case, we must calculate the forces and moments based on a calibration matrix. The function calculate_forces_and_moments does this calculation and already includes calibration matrices based on SmartWheels' serial numbers. For example: new_kinetics = ktk . pushrimkinetics . calculate_forces_and_moments ( kinetics , 'LIO-123' ) plt . subplot ( 2 , 1 , 1 ) new_kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) new_kinetics . plot ( 'Moments' ) When the forces and moments are reconstructed from raw data, no modification has been applied on the signals by the SmartWheel software to account for wheel side. Therefore some signals may be inverted, as observed here.","title":"Calculate forces and moments"},{"location":"pushrimkinetics.html#removing-sinusoids-in-forces-and-moments","text":"We observe in the last graphs that sinusoidal offsets are presents mostly in the forces but also in the moments. We can auto-remove these offsets using remove_sinusoids . Let's apply this function on the data we just loaded. kinetics = ktk . pushrimkinetics . remove_sinusoids ( kinetics ) plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' ) This automatic method has only be validated for straight-line, level-ground propulsion. For any other condition, a baseline trial is required. A baseline trial is a trial where an operator pushes the wheelchair but no external force appart from gravity is applied on the instrumented wheel. For example: kinetics = ktk . pushrimkinetics . read_file ( 'data/pushrimkinetics/sample_swl_overground_propulsion_withrubber.csv' ) baseline = ktk . pushrimkinetics . read_file ( 'data/pushrimkinetics/sample_swl_overground_baseline_withrubber.csv' ) kinetics = ktk . pushrimkinetics . remove_sinusoids ( kinetics , baseline ) plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' )","title":"Removing sinusoids in forces and moments"},{"location":"pushrimkinetics.html#calculate-velocity-and-power","text":"Thee wheel velocity is calculated from the wheel angle with a derivative Savitsky-Golay filter, using the calculate_velocity function. Once the velocity has been calculated, the output power can also be calculated by multiplying the velocity by the propulsion moment, using the calculate_power function. kinetics = ktk . pushrimkinetics . calculate_velocity ( kinetics ) kinetics = ktk . pushrimkinetics . calculate_power ( kinetics ) kinetics . plot ([ 'Velocity' , 'Power' ])","title":"Calculate velocity and power"},{"location":"pushrimkinetics.html#detecting-pushes","text":"The function detect_pushes allows detecting pushes and recoveries automatically based on a double-threshold. kinetics = ktk . pushrimkinetics . detect_pushes ( kinetics ) kinetics TimeSeries with attributes: data: <dict with 7 entries>, data_info: <dict with 6 entries>, events: <list of 50 items>, time: <array of shape (7682,)>, time_info: <dict with 1 entries> We see that the TimeSeries now has 52 events. Let's see these events on a plot. plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' )","title":"Detecting pushes"},{"location":"pushrimkinetics.html#time-normalizing-data","text":"Now, we may be intested in time-normalizing our pushes. For example, if we are interested to find the average progression of the push force. Time-normalizing is not specific to the ktk.pushrimkinetics module, it is in the ktk.cycles module. To analyze the push phase, we want to time-normalize each push from the push event to the recovery event. kinetics = ktk . cycles . time_normalize ( kinetics , 'push' , 'recovery' ) plt . subplot ( 2 , 1 , 1 ) kinetics . plot ( 'Forces' ) plt . subplot ( 2 , 1 , 2 ) kinetics . plot ( 'Moments' ) It is now possible to extract each push in a i_cycle x i_percent x i_component form, using the ktk.cycles.get_reshaped_time_normalized_data method. data = ktk . cycles . get_reshaped_time_normalized_data ( kinetics ) data { 'Angle': <array of shape (25, 100)>, 'Channels': <array of shape (25, 100, 6)>, 'Forces': <array of shape (25, 100, 4)>, 'Index': <array of shape (25, 100)>, 'Moments': <array of shape (25, 100, 4)>, 'Power': <array of shape (25, 100)>, 'Velocity': <array of shape (25, 100)> } Plot the normalized force curves one on top of each other: for i in range ( data [ 'Forces' ] . shape [ 0 ]): plt . plot ( data [ 'Forces' ][ i ])","title":"Time-normalizing data"},{"location":"timeseries.html","text":"KTK's main data structure: TimeSeries The TimeSeries class is the basis of most ktk modules and is the only \"new\" class ktk users have to learn. The three roles of the TimeSeries class are to: organize multidimensional data in time; deal with events; associate metadata to data. This class is largely inspired by Matlab's timeseries and tscollection . To better understand the role and capabilities of the TimeSeries class, we will begin by opening some columns of a csv file as a Pandas DataFrame. This file contains forces and moments applied on an instrumented wheelchair wheel during the propulsion of a manual wheelchair. import ktk import pandas as pd import numpy as np # Read some columns df = pd . read_csv ( 'data/timeseries/smartwheel.csv' , usecols = [ 18 , 19 , 20 , 21 , 22 , 23 ], names = [ 'Fx' , 'Fy' , 'Fz' , 'Mx' , 'My' , 'Mz' ], nrows = 5000 ) # Assign time to the DataFrame's index, where the sampling rate is 240 Hz. df . index = np . arange ( df . shape [ 0 ]) / 240 df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Fx Fy Fz Mx My Mz 0.000000 1.27 -0.89 -0.20 -0.03 0.05 -0.03 0.004167 0.49 -0.83 -0.51 0.02 -0.01 -0.13 0.008333 0.00 -0.78 -0.51 0.04 -0.07 -0.18 0.012500 -0.13 -0.93 -0.41 0.03 -0.16 -0.18 0.016667 -0.02 -0.89 0.00 0.01 -0.21 -0.13 ... ... ... ... ... ... ... 20.812500 0.87 -1.73 0.00 0.08 -0.07 -0.03 20.816667 0.68 -2.38 0.20 0.07 -0.05 0.08 20.820833 0.39 -2.72 0.20 0.02 0.00 0.10 20.825000 0.32 -2.51 0.41 0.04 0.05 0.08 20.829167 0.39 -1.54 0.82 0.08 0.06 -0.10 5000 rows \u00d7 6 columns Now, we can convert this DataFrame to a TimeSeries: ts = ktk . TimeSeries . from_dataframe ( df ) ts TimeSeries with attributes: data: <dict with 6 entries>, data_info: <dict with 0 entries>, events: <list of 0 items>, time: <array of shape (5000,)>, time_info: <dict with 1 entries> Properties time and data The time property is the time vector, which tells at which time correspond each of the samples. ts . time array([ 0. , 0.00416667, 0.00833333, ..., 20.82083333, 20.825 , 20.82916667]) The data property contains the TimeSeries' data in a dictionary. Each of the 6 DataFrame's columns now corresponds to a data key. ts . data { 'Fx': <array of shape (5000,)>, 'Fy': <array of shape (5000,)>, 'Fz': <array of shape (5000,)>, 'Mx': <array of shape (5000,)>, 'My': <array of shape (5000,)>, 'Mz': <array of shape (5000,)> } In reality, Fx, Fy and Fz are components of a single entity which is a force vector. Similarly, Mx, My and Mz are components of a single entity which is a moment vector. Let's see what happens if we name the DataFrames' columns differently. df . columns = [ 'Forces[0]' , 'Forces[1]' , 'Forces[2]' , 'Moments[0]' , 'Moments[1]' , 'Moments[2]' ] df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Forces[0] Forces[1] Forces[2] Moments[0] Moments[1] Moments[2] 0.000000 1.27 -0.89 -0.20 -0.03 0.05 -0.03 0.004167 0.49 -0.83 -0.51 0.02 -0.01 -0.13 0.008333 0.00 -0.78 -0.51 0.04 -0.07 -0.18 0.012500 -0.13 -0.93 -0.41 0.03 -0.16 -0.18 0.016667 -0.02 -0.89 0.00 0.01 -0.21 -0.13 ... ... ... ... ... ... ... 20.812500 0.87 -1.73 0.00 0.08 -0.07 -0.03 20.816667 0.68 -2.38 0.20 0.07 -0.05 0.08 20.820833 0.39 -2.72 0.20 0.02 0.00 0.10 20.825000 0.32 -2.51 0.41 0.04 0.05 0.08 20.829167 0.39 -1.54 0.82 0.08 0.06 -0.10 5000 rows \u00d7 6 columns Now we convert this DataFrame to a TimeSeries: ts = ktk . TimeSeries . from_dataframe ( df ) ts . data { 'Forces': <array of shape (5000, 3)>, 'Moments': <array of shape (5000, 3)> } Instead of being separated into 6 separate components, the three components of both the forces and moments are now grouped in two Nx3 arrays. This may greatly simplify subsequent data processing. For example, if we are interested in calculating the vectorial sum of the forces, then one could add this new data to the TimeSeries with this line: ts . data [ 'Ftot' ] = np . sqrt ( np . sum ( ts . data [ 'Forces' ] ** 2 , axis = 1 )) ts . data { 'Forces': <array of shape (5000, 3)>, 'Ftot': <array of shape (5000,)>, 'Moments': <array of shape (5000, 3)> } time_info and data_info The time_info property associates metadata to the time vector. It is a dictionary where each key is the name of one metadata. By default, time_info includes the Unit metadata, which corresponds to s . Any other metadata can be added by adding new keys in time_info . ts . time_info { 'Unit': 's' } Similarly, the data_info property associates metadata to data. This property is a dictionary of dictionaries, where the first key corresponds to the data key, and the second key is the metadata. The add_data_info method eases the management of data_info . ts . add_data_info ( 'Forces' , 'Unit' , 'N' ) ts . add_data_info ( 'Moments' , 'Unit' , 'Nm' ) ts . add_data_info ( 'Ftot' , 'Unit' , 'N' ) Unless explicitly mentioned, metadata is not used for calculation. It is rather a way to clarify the data by adding information to it. Some ktk functions however read those metadata: for example, the TimeSeries.plot method looks for Unit information and print it on the y axis. ts . plot () events In the figure above, we see that the TimeSeries has cyclic information that could be characterized by events. A first spike was generated at about 4 seconds: this event corresponds to a synchronization signal that we generated by gently impacting the instrumented pushrim. Then, we see a series of pushes and recoveries. For now, we will add these events in the TimeSeries by hand. ts . add_event ( 4.35 , 'sync' ) ts . add_event ( 8.56 , 'push' ) ts . add_event ( 9.93 , 'recovery' ) ts . add_event ( 10.50 , 'push' ) ts . add_event ( 11.12 , 'recovery' ) ts . add_event ( 11.78 , 'push' ) ts . add_event ( 12.33 , 'recovery' ) ts . add_event ( 13.39 , 'push' ) ts . add_event ( 13.88 , 'recovery' ) ts . add_event ( 14.86 , 'push' ) ts . add_event ( 15.30 , 'recovery' ) These events are now added to the TimeSeries' list of events: ts . events [[4.35, 'sync'], [8.56, 'push'], [9.93, 'recovery'], [10.5, 'push'], [11.12, 'recovery'], [11.78, 'push'], [12.33, 'recovery'], [13.39, 'push'], [13.88, 'recovery'], [14.86, 'push'], [15.3, 'recovery']] If we plot again the TimeSeries, we can see the added events. ts . plot () Using events to synchronize TimeSeries Let's see how we can make use of these events. First, the sync event can be used to set the zero-time, in the case where, for example, this wheel must be synchronized with another wheel, or with another instrument that also has a synchronization event. The method sync_event shifts the TimeSeries' time and events time so that the sync event becomes the new \"zero-time\". ts . sync_event ( 'sync' ) ts . plot () Using events to extract sub-TimeSeries The TimeSeries class comes with a myriad of methods such as get_ts_after_event , get_ts_between_events , etc. For example, if we want to analyze data of the four first pushes and get rid of any other data, we could extract a new TimeSeries that contains only these data: # Extract data push event 0 up to push event 4. ts2 = ts . get_ts_between_events ( 'push' , 'push' , 0 , 4 , inclusive = True ) # Remove the events that are not contained into the new time range. ts2 . trim_events () ts2 . plot () Subsetting and merging timeseries We can use the get_subset method to extract some signals from a TimeSeries. For example, if we only want to keep force information and get rid of the moments: ts3 = ts2 . get_subset ([ 'Forces' , 'Ftot' ]) ts3 . data { 'Forces': <array of shape (1514, 3)>, 'Ftot': <array of shape (1514,)> } ts3 . plot () Using python's list comprehension is a nice way to extract a TimeSeries subset based on a selection criterion. For example, we could have obtained ts3 by selecting every data key that begins with the letter 'F': ts3 = ts2 . get_subset ([ key for key in ts2 . data if key . startswith ( 'F' )]) ts3 . data { 'Forces': <array of shape (1514, 3)>, 'Ftot': <array of shape (1514,)> } For more information on the TimeSeries class, please refer to the API reference .","title":"TimeSeries"},{"location":"timeseries.html#ktks-main-data-structure-timeseries","text":"The TimeSeries class is the basis of most ktk modules and is the only \"new\" class ktk users have to learn. The three roles of the TimeSeries class are to: organize multidimensional data in time; deal with events; associate metadata to data. This class is largely inspired by Matlab's timeseries and tscollection . To better understand the role and capabilities of the TimeSeries class, we will begin by opening some columns of a csv file as a Pandas DataFrame. This file contains forces and moments applied on an instrumented wheelchair wheel during the propulsion of a manual wheelchair. import ktk import pandas as pd import numpy as np # Read some columns df = pd . read_csv ( 'data/timeseries/smartwheel.csv' , usecols = [ 18 , 19 , 20 , 21 , 22 , 23 ], names = [ 'Fx' , 'Fy' , 'Fz' , 'Mx' , 'My' , 'Mz' ], nrows = 5000 ) # Assign time to the DataFrame's index, where the sampling rate is 240 Hz. df . index = np . arange ( df . shape [ 0 ]) / 240 df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Fx Fy Fz Mx My Mz 0.000000 1.27 -0.89 -0.20 -0.03 0.05 -0.03 0.004167 0.49 -0.83 -0.51 0.02 -0.01 -0.13 0.008333 0.00 -0.78 -0.51 0.04 -0.07 -0.18 0.012500 -0.13 -0.93 -0.41 0.03 -0.16 -0.18 0.016667 -0.02 -0.89 0.00 0.01 -0.21 -0.13 ... ... ... ... ... ... ... 20.812500 0.87 -1.73 0.00 0.08 -0.07 -0.03 20.816667 0.68 -2.38 0.20 0.07 -0.05 0.08 20.820833 0.39 -2.72 0.20 0.02 0.00 0.10 20.825000 0.32 -2.51 0.41 0.04 0.05 0.08 20.829167 0.39 -1.54 0.82 0.08 0.06 -0.10 5000 rows \u00d7 6 columns Now, we can convert this DataFrame to a TimeSeries: ts = ktk . TimeSeries . from_dataframe ( df ) ts TimeSeries with attributes: data: <dict with 6 entries>, data_info: <dict with 0 entries>, events: <list of 0 items>, time: <array of shape (5000,)>, time_info: <dict with 1 entries>","title":"KTK's main data structure: TimeSeries"},{"location":"timeseries.html#properties","text":"","title":"Properties"},{"location":"timeseries.html#time-and-data","text":"The time property is the time vector, which tells at which time correspond each of the samples. ts . time array([ 0. , 0.00416667, 0.00833333, ..., 20.82083333, 20.825 , 20.82916667]) The data property contains the TimeSeries' data in a dictionary. Each of the 6 DataFrame's columns now corresponds to a data key. ts . data { 'Fx': <array of shape (5000,)>, 'Fy': <array of shape (5000,)>, 'Fz': <array of shape (5000,)>, 'Mx': <array of shape (5000,)>, 'My': <array of shape (5000,)>, 'Mz': <array of shape (5000,)> } In reality, Fx, Fy and Fz are components of a single entity which is a force vector. Similarly, Mx, My and Mz are components of a single entity which is a moment vector. Let's see what happens if we name the DataFrames' columns differently. df . columns = [ 'Forces[0]' , 'Forces[1]' , 'Forces[2]' , 'Moments[0]' , 'Moments[1]' , 'Moments[2]' ] df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Forces[0] Forces[1] Forces[2] Moments[0] Moments[1] Moments[2] 0.000000 1.27 -0.89 -0.20 -0.03 0.05 -0.03 0.004167 0.49 -0.83 -0.51 0.02 -0.01 -0.13 0.008333 0.00 -0.78 -0.51 0.04 -0.07 -0.18 0.012500 -0.13 -0.93 -0.41 0.03 -0.16 -0.18 0.016667 -0.02 -0.89 0.00 0.01 -0.21 -0.13 ... ... ... ... ... ... ... 20.812500 0.87 -1.73 0.00 0.08 -0.07 -0.03 20.816667 0.68 -2.38 0.20 0.07 -0.05 0.08 20.820833 0.39 -2.72 0.20 0.02 0.00 0.10 20.825000 0.32 -2.51 0.41 0.04 0.05 0.08 20.829167 0.39 -1.54 0.82 0.08 0.06 -0.10 5000 rows \u00d7 6 columns Now we convert this DataFrame to a TimeSeries: ts = ktk . TimeSeries . from_dataframe ( df ) ts . data { 'Forces': <array of shape (5000, 3)>, 'Moments': <array of shape (5000, 3)> } Instead of being separated into 6 separate components, the three components of both the forces and moments are now grouped in two Nx3 arrays. This may greatly simplify subsequent data processing. For example, if we are interested in calculating the vectorial sum of the forces, then one could add this new data to the TimeSeries with this line: ts . data [ 'Ftot' ] = np . sqrt ( np . sum ( ts . data [ 'Forces' ] ** 2 , axis = 1 )) ts . data { 'Forces': <array of shape (5000, 3)>, 'Ftot': <array of shape (5000,)>, 'Moments': <array of shape (5000, 3)> }","title":"time and data"},{"location":"timeseries.html#time_info-and-data_info","text":"The time_info property associates metadata to the time vector. It is a dictionary where each key is the name of one metadata. By default, time_info includes the Unit metadata, which corresponds to s . Any other metadata can be added by adding new keys in time_info . ts . time_info { 'Unit': 's' } Similarly, the data_info property associates metadata to data. This property is a dictionary of dictionaries, where the first key corresponds to the data key, and the second key is the metadata. The add_data_info method eases the management of data_info . ts . add_data_info ( 'Forces' , 'Unit' , 'N' ) ts . add_data_info ( 'Moments' , 'Unit' , 'Nm' ) ts . add_data_info ( 'Ftot' , 'Unit' , 'N' ) Unless explicitly mentioned, metadata is not used for calculation. It is rather a way to clarify the data by adding information to it. Some ktk functions however read those metadata: for example, the TimeSeries.plot method looks for Unit information and print it on the y axis. ts . plot ()","title":"time_info and data_info"},{"location":"timeseries.html#events","text":"In the figure above, we see that the TimeSeries has cyclic information that could be characterized by events. A first spike was generated at about 4 seconds: this event corresponds to a synchronization signal that we generated by gently impacting the instrumented pushrim. Then, we see a series of pushes and recoveries. For now, we will add these events in the TimeSeries by hand. ts . add_event ( 4.35 , 'sync' ) ts . add_event ( 8.56 , 'push' ) ts . add_event ( 9.93 , 'recovery' ) ts . add_event ( 10.50 , 'push' ) ts . add_event ( 11.12 , 'recovery' ) ts . add_event ( 11.78 , 'push' ) ts . add_event ( 12.33 , 'recovery' ) ts . add_event ( 13.39 , 'push' ) ts . add_event ( 13.88 , 'recovery' ) ts . add_event ( 14.86 , 'push' ) ts . add_event ( 15.30 , 'recovery' ) These events are now added to the TimeSeries' list of events: ts . events [[4.35, 'sync'], [8.56, 'push'], [9.93, 'recovery'], [10.5, 'push'], [11.12, 'recovery'], [11.78, 'push'], [12.33, 'recovery'], [13.39, 'push'], [13.88, 'recovery'], [14.86, 'push'], [15.3, 'recovery']] If we plot again the TimeSeries, we can see the added events. ts . plot ()","title":"events"},{"location":"timeseries.html#using-events-to-synchronize-timeseries","text":"Let's see how we can make use of these events. First, the sync event can be used to set the zero-time, in the case where, for example, this wheel must be synchronized with another wheel, or with another instrument that also has a synchronization event. The method sync_event shifts the TimeSeries' time and events time so that the sync event becomes the new \"zero-time\". ts . sync_event ( 'sync' ) ts . plot ()","title":"Using events to synchronize TimeSeries"},{"location":"timeseries.html#using-events-to-extract-sub-timeseries","text":"The TimeSeries class comes with a myriad of methods such as get_ts_after_event , get_ts_between_events , etc. For example, if we want to analyze data of the four first pushes and get rid of any other data, we could extract a new TimeSeries that contains only these data: # Extract data push event 0 up to push event 4. ts2 = ts . get_ts_between_events ( 'push' , 'push' , 0 , 4 , inclusive = True ) # Remove the events that are not contained into the new time range. ts2 . trim_events () ts2 . plot ()","title":"Using events to extract sub-TimeSeries"},{"location":"timeseries.html#subsetting-and-merging-timeseries","text":"We can use the get_subset method to extract some signals from a TimeSeries. For example, if we only want to keep force information and get rid of the moments: ts3 = ts2 . get_subset ([ 'Forces' , 'Ftot' ]) ts3 . data { 'Forces': <array of shape (1514, 3)>, 'Ftot': <array of shape (1514,)> } ts3 . plot () Using python's list comprehension is a nice way to extract a TimeSeries subset based on a selection criterion. For example, we could have obtained ts3 by selecting every data key that begins with the letter 'F': ts3 = ts2 . get_subset ([ key for key in ts2 . data if key . startswith ( 'F' )]) ts3 . data { 'Forces': <array of shape (1514, 3)>, 'Ftot': <array of shape (1514,)> } For more information on the TimeSeries class, please refer to the API reference .","title":"Subsetting and merging timeseries"}]}